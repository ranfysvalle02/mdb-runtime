{% extends "base.html" %}

{% block title %}{{ conversation.title }} | orby{% endblock %}

{% block extra_css %}
<style>
    /* --- CHAT CONSOLE --- */
    .conversation-container {
        display: flex;
        gap: 20px;
        width: 100%;
        max-width: 1400px;
        height: calc(100vh - 100px);
        max-height: 800px;
        position: relative;
        z-index: 10;
    }

    .conversation-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
        
        /* --- SMART GLASSMORPHISM FOR READABILITY --- */
        background: radial-gradient(circle at center, rgba(26, 27, 47, 0.88) 0%, rgba(26, 27, 47, 0.75) 100%);
        backdrop-filter: blur(18px) saturate(180%);
        -webkit-backdrop-filter: blur(18px) saturate(180%);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 24px;
        box-shadow: 0 15px 40px rgba(0,0,0,0.5), 0 0 40px var(--glow-color) inset;
        position: relative;
        transition: box-shadow 0.5s ease;
    }

    /* --- BACK BUTTON IN CONVERSATION --- */
    #back-to-conversations-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        display: flex;
        align-items: center;
        gap: 6px;
        color: rgba(255, 255, 255, 0.8);
        text-decoration: none;
        padding: 8px 14px;
        border-radius: 10px;
        transition: all 0.2s;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 20;
    }
    #back-to-conversations-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(138, 43, 226, 0.5);
        transform: translateX(-3px);
        color: #fff;
    }
    #back-to-conversations-btn svg {
        width: 18px;
        height: 18px;
    }

    /* The Orb as Avatar */
    #orb {
        width: 100px;
        height: 100px;
        position: absolute;
        top: -50px;
        left: 50%;
        transform: translateX(-50%);
        cursor: pointer;
        z-index: 15;
    }
    #orb::before {
        content: '';
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle at center, #ffffff 0%, #e6e6e6 30%, transparent 70%);
        border-radius: 50%;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        animation: orbPulse 5s ease-in-out infinite;
        transition: all 0.5s ease;
    }
    #orb.listening::before { animation: orbPulse 1.5s ease-in-out infinite; }
    #orb::after {
        content: '';
        position: absolute;
        top: -20%; left: -20%; width: 140%; height: 140%;
        background: radial-gradient(circle at center, var(--aura-color, var(--glow-color)), transparent 70%);
        border-radius: 50%;
        mix-blend-mode: screen;
        transition: background 0.5s ease;
    }
    @keyframes orbPulse { 
        0%, 100% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.5); transform: scale(1); } 
        50% { box-shadow: 0 0 50px rgba(255, 255, 255, 0.8); transform: scale(1.05); } 
    }

    .conversation-header {
        padding: 60px 20px 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
    }

    .conversation-title {
        font-size: 18px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
    }

    .conversation-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
    }
    .conversation-messages::-webkit-scrollbar { width: 6px; }
    .conversation-messages::-webkit-scrollbar-track { background: transparent; }
    .conversation-messages::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }

    .message { 
        display: flex; 
        align-items: flex-start; 
        gap: 12px; 
        max-width: 85%; 
        opacity: 0; 
        animation: fadeInWithBounce 0.6s cubic-bezier(0.2, 0.8, 0.2, 1.2) forwards; 
        margin-bottom: 15px;
    }
    @keyframes fadeInWithBounce { 
        from { opacity: 0; transform: translateY(20px) scale(0.9); } 
        to { opacity: 1; transform: translateY(0) scale(1); } 
    }
    .message.user { 
        align-self: flex-end; 
        flex-direction: row-reverse; 
    }
    .message.assistant { 
        align-self: flex-start; 
    }
    
    .message .avatar { 
        width: 38px; 
        height: 38px; 
        border-radius: 50%; 
        flex-shrink: 0; 
        fill: #e2e8f0; 
    }
    .message.user .avatar { fill: #c084fc; }

    .message .text { 
        padding: 12px 18px; 
        border-radius: 20px; 
        font-size: 16px; 
        line-height: 1.5; 
        word-break: break-word; 
        color: #f1f5f9; 
    }
    .message.user .text { 
        background: linear-gradient(135deg, #8b5cf6, #6366f1); 
        border-bottom-right-radius: 6px; 
    }
    .message.assistant .text { 
        background: #2a2d48; 
        border-bottom-left-radius: 6px; 
    }
    
    /* Code block styling within messages */
    .message .text pre {
        background: rgba(0,0,0,0.3);
        padding: 10px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 10px 0;
    }
    .message .text code {
        font-family: 'Courier New', Courier, monospace;
        font-size: 14px;
    }

    .message-time {
        font-size: 11px;
        opacity: 0.5;
        margin-top: 4px;
        padding: 0 4px;
    }

    .typing-indicator { 
        display: flex; 
        align-items: center; 
        gap: 5px; 
        padding: 12px 18px; 
    }
    .typing-indicator span { 
        height: 8px; 
        width: 8px; 
        background-color: rgba(255,255,255,0.5); 
        border-radius: 50%; 
        animation: bounce 1.3s infinite ease-in-out; 
    }
    .typing-indicator span:nth-of-type(2) { animation-delay: 0.15s; }
    .typing-indicator span:nth-of-type(3) { animation-delay: 0.3s; }
    @keyframes bounce { 
        0%, 80%, 100% { transform: scale(0); } 
        40% { transform: scale(1.0); } 
    }

    .conversation-input {
        padding: 15px 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        flex-shrink: 0;
        border-bottom-left-radius: 24px;
        border-bottom-right-radius: 24px;
        position: relative;
    }

    .conversation-input.drag-over {
        background: rgba(138, 43, 226, 0.1);
        border-top-color: rgba(138, 43, 226, 0.5);
    }

    .input-form {
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
    }

    /* File Upload Button */
    #file-upload-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: all 0.2s;
        position: relative;
        overflow: hidden;
    }

    #file-upload-btn:hover {
        background: rgba(138, 43, 226, 0.2);
        border-color: rgba(138, 43, 226, 0.5);
        transform: scale(1.05);
        box-shadow: 0 0 15px rgba(138, 43, 226, 0.3);
    }

    #file-upload-btn:active {
        transform: scale(0.95);
    }

    #file-upload-btn.has-files {
        background: rgba(138, 43, 226, 0.3);
        border-color: rgba(138, 43, 226, 0.6);
        color: #c084fc;
        animation: pulseUpload 2s ease-in-out infinite;
    }
    @keyframes pulseUpload {
        0%, 100% { box-shadow: 0 0 0 rgba(138, 43, 226, 0.4); }
        50% { box-shadow: 0 0 10px rgba(138, 43, 226, 0.6); }
    }

    #file-input {
        display: none;
    }

    /* File Preview Container */
    #file-preview-container {
        margin-bottom: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 200px;
        overflow-y: auto;
        padding: 4px;
        /* Improved empty state handling */
        min-height: 0;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        animation: containerFadeIn 0.3s ease-out;
    }
    @keyframes containerFadeIn {
        from { opacity: 0; transform: translateY(-5px); }
        to { opacity: 1; transform: translateY(0); }
    }
    #file-preview-container:empty {
        margin-bottom: 0;
        padding: 0;
    }
    #file-preview-container::-webkit-scrollbar { width: 4px; }
    #file-preview-container::-webkit-scrollbar-track { background: transparent; }
    #file-preview-container::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 2px; }

    /* File Preview */
    .file-preview {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 14px;
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.15), rgba(99, 102, 241, 0.15));
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 10px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.95);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        animation: slideInFile 0.3s ease-out;
        position: relative;
        overflow: hidden;
    }
    @keyframes slideInFile {
        from { opacity: 0; transform: translateX(-10px) scale(0.95); }
        to { opacity: 1; transform: translateX(0) scale(1); }
    }
    
    .file-preview::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.5s ease;
    }
    
    .file-preview.processing::before {
        left: 100%;
        animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
        0% { left: -100%; }
        100% { left: 100%; }
    }
    
    .file-preview:hover:not(.processing):not(.completed) {
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.25), rgba(99, 102, 241, 0.25));
        border-color: rgba(138, 43, 226, 0.5);
        transform: translateX(2px);
    }
    
    .file-preview.processing {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(138, 43, 226, 0.2));
        border-color: rgba(59, 130, 246, 0.5);
        animation: processingPulse 2s ease-in-out infinite;
    }
    @keyframes processingPulse {
        0%, 100% { 
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
        }
        50% { 
            border-color: rgba(59, 130, 246, 0.8);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
        }
    }
    
    .file-preview.completed {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(59, 130, 246, 0.15));
        border-color: rgba(16, 185, 129, 0.5);
        animation: completeSlide 0.5s ease-out;
    }
    @keyframes completeSlide {
        from { transform: scale(1); }
        50% { transform: scale(1.02); }
        to { transform: scale(1); }
    }

    .file-preview-icon {
        font-size: 18px;
        flex-shrink: 0;
        transition: transform 0.3s ease;
    }
    
    .file-preview.processing .file-preview-icon {
        animation: iconSpin 2s linear infinite;
    }
    @keyframes iconSpin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .file-preview.completed .file-preview-icon {
        animation: iconBounce 0.6s ease-out;
    }
    @keyframes iconBounce {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.3); }
    }
    
    .file-preview-status {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.7);
        margin-top: 4px;
        opacity: 0;
        transform: translateY(-5px);
        transition: all 0.3s ease;
    }
    
    .file-preview.processing .file-preview-status,
    .file-preview.completed .file-preview-status {
        opacity: 1;
        transform: translateY(0);
    }
    
    .file-preview-progress {
        width: 100%;
        height: 2px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 1px;
        overflow: hidden;
        margin-top: 6px;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .file-preview.processing .file-preview-progress {
        opacity: 1;
    }
    
    .file-preview-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, rgba(59, 130, 246, 1), rgba(138, 43, 226, 1));
        border-radius: 1px;
        transition: width 0.3s ease;
        animation: progressPulse 1.5s ease-in-out infinite;
    }
    @keyframes progressPulse {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
    }

    .file-preview-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .file-preview-name {
        font-weight: 500;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        color: rgba(255, 255, 255, 0.95);
    }

    .file-preview-size {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
    }

    .file-preview-remove {
        background: rgba(248, 81, 73, 0.2);
        border: 1px solid rgba(248, 81, 73, 0.3);
        color: #f85149;
        border-radius: 6px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
    }

    .file-preview-remove:hover {
        background: rgba(248, 81, 73, 0.4);
        border-color: rgba(248, 81, 73, 0.6);
        transform: scale(1.1);
    }

    .file-preview-remove:active {
        transform: scale(0.95);
    }

    .file-upload-status {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: rgba(59, 130, 246, 0.15);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 8px;
        font-size: 12px;
        color: #93c5fd;
        margin-bottom: 8px;
    }

    /* Memory Extraction Indicator */
    .memory-extraction-indicator {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 16px 20px;
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%);
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 12px;
        animation: pulseGlow 2s ease-in-out infinite;
    }
    @keyframes pulseGlow {
        0%, 100% { border-color: rgba(138, 43, 226, 0.3); box-shadow: 0 0 0 0 rgba(138, 43, 226, 0.4); }
        50% { border-color: rgba(138, 43, 226, 0.6); box-shadow: 0 0 20px 5px rgba(138, 43, 226, 0.2); }
    }

    .memory-extraction-spinner {
        flex-shrink: 0;
        animation: spin 2s linear infinite;
    }
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    .memory-extraction-text {
        flex: 1;
    }

    .memory-extraction-title {
        font-size: 15px;
        font-weight: 600;
        color: #e0e7ff;
        margin-bottom: 4px;
    }

    .memory-extraction-subtitle {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
    }

    .memory-extraction-success {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 16px 20px;
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%);
        border: 1px solid rgba(34, 197, 94, 0.3);
        border-radius: 12px;
        animation: successSlideIn 0.4s ease-out;
    }
    @keyframes successSlideIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .memory-extraction-success-icon {
        flex-shrink: 0;
        font-size: 24px;
        animation: successBounce 0.6s ease-out;
    }
    @keyframes successBounce {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.2); }
    }

    .memory-extraction-success-text {
        flex: 1;
    }

    .memory-extraction-success-title {
        font-size: 15px;
        font-weight: 600;
        color: #86efac;
        margin-bottom: 4px;
    }

    .memory-extraction-success-subtitle {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
    }

    /* Drag Drop Overlay */
    .drag-drop-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(138, 43, 226, 0.25);
        backdrop-filter: blur(8px);
        border: 4px dashed rgba(138, 43, 226, 0.8);
        z-index: 9999;
        display: none;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        animation: pulseBorder 1.5s ease-in-out infinite;
    }
    @keyframes pulseBorder {
        0%, 100% { border-color: rgba(138, 43, 226, 0.8); }
        50% { border-color: rgba(138, 43, 226, 1); }
    }

    .drag-drop-overlay.active {
        display: flex;
    }

    .drag-drop-content {
        text-align: center;
        color: #fff;
        font-size: 28px;
        font-weight: 600;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .drag-drop-content::before {
        content: "üìé";
        display: block;
        font-size: 80px;
        margin-bottom: 20px;
        animation: bounce 1s ease-in-out infinite;
    }
    @keyframes bounce {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
    }

    .input-form input {
        flex: 1;
        padding: 12px 20px;
        border-radius: 22px;
        border: 1px solid transparent;
        outline: none;
        font-size: 16px;
        background: rgba(0, 0, 0, 0.2);
        color: #fff;
        transition: all 0.3s;
    }
    .input-form input:focus {
        background: rgba(0, 0, 0, 0.1);
        border-color: rgba(138, 43, 226, 0.5);
        box-shadow: 0 0 15px rgba(138, 43, 226, 0.3);
    }
    .input-form input::placeholder {
        color: #94a3b8;
    }
    .input-form input.has-files::placeholder {
        color: rgba(138, 43, 226, 0.6);
    }
    
    .category-select-input {
        padding: 8px 12px;
        background: rgba(138, 43, 226, 0.2);
        border: 1px solid rgba(138, 43, 226, 0.4);
        border-radius: 10px;
        color: #c084fc;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 100px;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23c084fc' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 8px center;
        padding-right: 30px;
    }
    
    .category-select-input:hover {
        background-color: rgba(138, 43, 226, 0.3);
        border-color: rgba(138, 43, 226, 0.6);
    }
    
    .category-select-input:focus {
        outline: none;
        border-color: rgba(138, 43, 226, 0.8);
        box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2);
        background-color: rgba(138, 43, 226, 0.25);
    }
    
    .category-select-input option {
        background: #1a1b2f;
        color: #fff;
        padding: 8px;
    }

    #send-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: #6b21a8;
        color: #fff;
        font-size: 20px;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: scale(0.8);
        transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1.2);
    }
    #send-btn.active, #send-btn:hover {
        background: #8A2BE2;
        transform: scale(1);
    }
    #send-btn:active {
        transform: scale(0.9) !important;
    }

    /* Memory Sidebar - Redesigned */
    .memory-sidebar {
        width: 380px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        position: relative;
    }

    .memory-panel {
        background: radial-gradient(circle at center, rgba(26, 27, 47, 0.92) 0%, rgba(26, 27, 47, 0.78) 100%);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 20px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        max-height: calc(100vh - 200px);
        box-shadow: 0 12px 40px rgba(0,0,0,0.4), 0 0 0 1px rgba(138, 43, 226, 0.1) inset;
        transition: all 0.3s ease;
    }
    
    .memory-panel:hover {
        border-color: rgba(138, 43, 226, 0.3);
        box-shadow: 0 16px 48px rgba(0,0,0,0.5), 0 0 0 1px rgba(138, 43, 226, 0.2) inset;
    }

    .memory-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        padding-bottom: 14px;
        border-bottom: 2px solid rgba(138, 43, 226, 0.2);
        position: relative;
    }
    
    .memory-panel-header::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 60px;
        height: 2px;
        background: linear-gradient(90deg, rgba(138, 43, 226, 0.8), transparent);
        border-radius: 2px;
    }

    .memory-panel-title {
        font-weight: 700;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 10px;
        color: rgba(255, 255, 255, 0.98);
        letter-spacing: -0.3px;
        flex-wrap: wrap;
    }
    
    .memory-count-badge {
        font-size: 12px;
        font-weight: 500;
        padding: 4px 10px;
        background: rgba(138, 43, 226, 0.2);
        border: 1px solid rgba(138, 43, 226, 0.4);
        border-radius: 12px;
        color: #c084fc;
        margin-left: auto;
        transition: all 0.2s ease;
    }
    
    .memory-count-badge.has-filtered {
        background: rgba(255, 193, 7, 0.2);
        border-color: rgba(255, 193, 7, 0.4);
        color: #ffc107;
        cursor: help;
    }
    
    .memory-count-badge.has-filtered:hover {
        background: rgba(255, 193, 7, 0.3);
        border-color: rgba(255, 193, 7, 0.6);
    }

    .memory-panel-title::before {
        content: "üß†";
        font-size: 20px;
        filter: drop-shadow(0 2px 4px rgba(138, 43, 226, 0.3));
    }
    
    .memory-context-indicator {
        font-size: 14px;
        opacity: 0.7;
        margin-left: 4px;
        cursor: help;
    }
    
    .connection-status {
        display: inline-flex;
        align-items: center;
        margin-left: 8px;
        vertical-align: middle;
    }
    
    .connection-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #f85149;
        display: inline-block;
        animation: pulse 2s ease-in-out infinite;
        box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.7);
    }
    
    .connection-dot.connected {
        background: #10b981;
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
        animation: pulseGreen 2s ease-in-out infinite;
    }
    
    .connection-dot.connecting {
        background: #f59e0b;
        box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
        animation: pulseYellow 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.7);
        }
        70% {
            box-shadow: 0 0 0 6px rgba(248, 81, 73, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(248, 81, 73, 0);
        }
    }
    
    @keyframes pulseGreen {
        0% {
            box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
        }
        70% {
            box-shadow: 0 0 0 6px rgba(16, 185, 129, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
        }
    }
    
    @keyframes pulseYellow {
        0% {
            box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
        }
        70% {
            box-shadow: 0 0 0 6px rgba(245, 158, 11, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(245, 158, 11, 0);
        }
    }
    
    .memory-panel-actions {
        display: flex;
        gap: 6px;
        align-items: center;
    }

    .memory-nav-btn {
        padding: 8px 12px;
        font-size: 13px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        color: rgba(255, 255, 255, 0.9);
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: 500;
        position: relative;
        overflow: hidden;
    }
    
    .memory-nav-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.5s;
    }
    
    .memory-nav-btn:hover::before {
        left: 100%;
    }

    .memory-nav-btn:hover {
        background: rgba(138, 43, 226, 0.25);
        border-color: rgba(138, 43, 226, 0.5);
        color: #c084fc;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(138, 43, 226, 0.2);
    }
    
    .memory-nav-btn:active {
        transform: translateY(0);
    }
    
    .memory-nav-btn {
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(99, 102, 241, 0.2));
        border-color: rgba(138, 43, 226, 0.3);
    }

    /* Enhanced Search - Modern Design */
    .memory-search-container {
        position: relative;
        margin-bottom: 16px;
    }
    
    #memory-search-input {
        width: 100%;
        padding: 12px 16px 12px 44px;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.35);
        border: 1.5px solid rgba(255, 255, 255, 0.18);
        border-radius: 12px;
        color: #fff;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-weight: 400;
    }
    
    #memory-search-input::placeholder {
        color: rgba(255, 255, 255, 0.5);
        font-weight: 400;
    }
    
    #memory-search-input:focus {
        outline: none;
        background: rgba(0, 0, 0, 0.45);
        border-color: rgba(138, 43, 226, 0.7);
        box-shadow: 0 0 0 4px rgba(138, 43, 226, 0.15), 0 4px 12px rgba(138, 43, 226, 0.2);
        transform: translateY(-1px);
    }
    
    #memory-search-input.has-query {
        border-color: rgba(138, 43, 226, 0.6);
        background: rgba(138, 43, 226, 0.12);
        box-shadow: 0 0 0 2px rgba(138, 43, 226, 0.1);
    }
    
    .memory-search-icon {
        position: absolute;
        left: 14px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 16px;
        opacity: 0.6;
        pointer-events: none;
        transition: opacity 0.2s;
    }
    
    #memory-search-input:focus + .memory-search-icon,
    #memory-search-input.has-query + .memory-search-icon {
        opacity: 1;
        color: #c084fc;
    }

    /* Collapsible Filters */
    .filters-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        cursor: pointer;
        margin-bottom: 8px;
        transition: all 0.2s;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
    }
    .filters-toggle:hover {
        background: rgba(0, 0, 0, 0.3);
    }
    .filters-toggle.active {
        background: rgba(138, 43, 226, 0.15);
        border: 1px solid rgba(138, 43, 226, 0.3);
    }
    .filters-toggle-icon {
        transition: transform 0.2s;
        font-size: 10px;
    }
    .filters-toggle.active .filters-toggle-icon {
        transform: rotate(90deg);
    }

    .memory-filters {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out, margin-bottom 0.3s ease-out;
        margin-bottom: 0;
        padding: 0 8px;
        background: rgba(0, 0, 0, 0.15);
        border-radius: 8px;
    }
    .memory-filters.expanded {
        max-height: 300px;
        margin-bottom: 12px;
        padding: 10px;
    }

    .filter-group {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
    }

    .filter-group:last-child {
        margin-bottom: 0;
    }

    .filter-label {
        font-weight: 500;
        min-width: 70px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 11px;
    }

    .filter-select {
        flex: 1;
        padding: 6px 10px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        font-size: 12px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
    }
    .filter-select:hover {
        border-color: rgba(138, 43, 226, 0.4);
    }
    .filter-select:focus {
        outline: none;
        border-color: rgba(138, 43, 226, 0.6);
        box-shadow: 0 0 0 2px rgba(138, 43, 226, 0.1);
    }

    .add-category-btn {
        padding: 4px 8px;
        background: rgba(138, 43, 226, 0.3);
        color: #c084fc;
        border: 1px solid rgba(138, 43, 226, 0.4);
        border-radius: 5px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
        margin-left: 4px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }

    .add-category-btn:hover {
        background: rgba(138, 43, 226, 0.4);
        border-color: rgba(138, 43, 226, 0.6);
        transform: scale(1.05);
    }

    /* Active Filter Badges */
    .active-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 12px;
        min-height: 24px;
    }
    .filter-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        background: rgba(138, 43, 226, 0.2);
        border: 1px solid rgba(138, 43, 226, 0.4);
        border-radius: 12px;
        font-size: 11px;
        color: #c084fc;
    }
    .filter-badge .remove {
        cursor: pointer;
        font-size: 12px;
        opacity: 0.7;
        transition: opacity 0.2s;
    }
    .filter-badge .remove:hover {
        opacity: 1;
    }

    /* Memory List Container - Enhanced */
    #memory-context-list {
        flex: 1;
        overflow-y: auto;
        min-height: 200px;
        max-height: 500px;
        padding-right: 4px;
        margin-right: -4px;
    }
    #memory-context-list::-webkit-scrollbar { 
        width: 8px; 
    }
    #memory-context-list::-webkit-scrollbar-track { 
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
    }
    #memory-context-list::-webkit-scrollbar-thumb { 
        background: linear-gradient(180deg, rgba(138, 43, 226, 0.4), rgba(99, 102, 241, 0.4));
        border-radius: 4px;
        border: 2px solid transparent;
        background-clip: padding-box;
    }
    #memory-context-list::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, rgba(138, 43, 226, 0.6), rgba(99, 102, 241, 0.6));
        background-clip: padding-box;
    }

    /* Memory Loading State */
    .memory-loading-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        color: rgba(255, 255, 255, 0.6);
        animation: fadeIn 0.3s ease-in;
    }
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .memory-loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid rgba(138, 43, 226, 0.2);
        border-top-color: rgba(138, 43, 226, 0.8);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 16px;
    }
    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    .memory-loading-text {
        font-size: 14px;
        font-weight: 500;
        color: rgba(255, 255, 255, 0.7);
        text-align: center;
    }

    /* Memory Loading Modal - Blocks UI during memory operations */
    .memory-loading-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(8px);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .memory-loading-modal.show {
        opacity: 1;
        visibility: visible;
    }

    .memory-loading-modal-content {
        background: linear-gradient(135deg, rgba(26, 27, 47, 0.98), rgba(30, 31, 52, 0.98));
        border: 2px solid rgba(138, 43, 226, 0.5);
        border-radius: 20px;
        padding: 40px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(138, 43, 226, 0.2) inset;
        animation: modalSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    @keyframes modalSlideIn {
        from {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    .memory-loading-modal-header {
        text-align: center;
        margin-bottom: 24px;
    }

    .memory-loading-spinner-large {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(138, 43, 226, 0.2);
        border-top-color: rgba(138, 43, 226, 1);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }

    .memory-loading-modal-header h3 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
        color: #e0e7ff;
        text-align: center;
    }

    .memory-loading-modal-body {
        text-align: center;
    }

    .memory-loading-message {
        font-size: 15px;
        color: rgba(255, 255, 255, 0.8);
        margin-bottom: 16px;
        line-height: 1.5;
        font-weight: 500;
    }
    
    .memory-loading-steps {
        max-height: 250px;
        overflow-y: auto;
        margin-bottom: 16px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        border: 1px solid rgba(138, 43, 226, 0.2);
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .memory-loading-steps::-webkit-scrollbar {
        width: 4px;
    }
    
    .memory-loading-steps::-webkit-scrollbar-thumb {
        background: rgba(138, 43, 226, 0.4);
        border-radius: 2px;
    }
    
    .memory-loading-step {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        background: rgba(138, 43, 226, 0.1);
        border-radius: 6px;
        border-left: 3px solid rgba(138, 43, 226, 0.3);
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
        transition: all 0.3s ease;
        opacity: 0.6;
    }
    
    .memory-loading-step.active {
        opacity: 1;
        background: rgba(138, 43, 226, 0.2);
        border-left-color: rgba(138, 43, 226, 0.8);
        color: rgba(255, 255, 255, 0.9);
        animation: stepPulse 2s ease-in-out infinite;
    }
    
    @keyframes stepPulse {
        0%, 100% { border-left-color: rgba(138, 43, 226, 0.8); }
        50% { border-left-color: rgba(138, 43, 226, 1); }
    }
    
    .memory-loading-step-icon {
        font-size: 16px;
        flex-shrink: 0;
    }
    
    .memory-loading-step-text {
        flex: 1;
        text-align: left;
    }
    
    .memory-loading-actions {
        margin-top: 16px;
        display: flex;
        justify-content: center;
    }
    
    .memory-loading-abort-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        background: rgba(248, 81, 73, 0.2);
        border: 1px solid rgba(248, 81, 73, 0.4);
        border-radius: 8px;
        color: #f85149;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .memory-loading-abort-btn:hover {
        background: rgba(248, 81, 73, 0.3);
        border-color: rgba(248, 81, 73, 0.6);
        transform: scale(1.05);
    }
    
    .memory-loading-abort-btn:active {
        transform: scale(0.95);
    }

    .memory-loading-progress {
        width: 100%;
        height: 6px;
        background: rgba(138, 43, 226, 0.2);
        border-radius: 3px;
        overflow: hidden;
        margin-top: 16px;
    }

    .memory-loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, rgba(138, 43, 226, 1), rgba(99, 102, 241, 1));
        border-radius: 3px;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
    }

    .memory-item {
        padding: 8px 10px;
        margin-bottom: 6px;
        background: rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-left: 3px solid transparent;
        border-radius: 8px;
        font-size: 12.5px;
        line-height: 1.4;
        position: relative;
        cursor: pointer;
        transition: all 0.2s ease;
        color: rgba(255, 255, 255, 0.88);
        backdrop-filter: blur(8px);
    }
    
    .memory-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.05), transparent);
        opacity: 0;
        transition: opacity 0.3s;
        border-radius: 12px;
        pointer-events: none;
    }

    .memory-item:hover {
        background: rgba(0, 0, 0, 0.35);
        border-color: rgba(138, 43, 226, 0.4);
        border-left-color: rgba(138, 43, 226, 0.7);
        transform: translateX(2px);
        box-shadow: 0 2px 8px rgba(138, 43, 226, 0.2);
    }
    
    .memory-item:hover::before {
        opacity: 1;
    }

    .memory-item.active {
        border-color: rgba(138, 43, 226, 0.7);
        border-left-color: rgba(138, 43, 226, 1);
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(99, 102, 241, 0.15));
        box-shadow: 0 4px 20px rgba(138, 43, 226, 0.3), 0 0 0 1px rgba(138, 43, 226, 0.2) inset;
        transform: translateX(2px);
    }
    
    .memory-item.active::before {
        opacity: 1;
    }

    .memory-item-header {
        display: flex;
        align-items: flex-start;
        gap: 8px;
        margin-bottom: 6px;
    }

    .memory-icon {
        font-size: 16px;
        flex-shrink: 0;
        margin-top: 2px;
    }

    .memory-text {
        flex: 1;
        word-break: break-word;
    }
    
    .view-source-btn {
        flex-shrink: 0;
        padding: 4px 10px;
        font-size: 11px;
        background: rgba(16, 185, 129, 0.15);
        border: 1px solid rgba(16, 185, 129, 0.3);
        border-radius: 6px;
        color: #6ee7b7;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 4px;
        font-weight: 500;
        margin-left: auto;
    }
    
    .view-source-btn:hover {
        background: rgba(16, 185, 129, 0.25);
        border-color: rgba(16, 185, 129, 0.5);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.2);
    }
    
    .view-source-btn:active {
        transform: translateY(0);
    }
    
    .view-source-btn span {
        font-size: 12px;
    }

    .memory-metadata {
        font-size: 9px;
        opacity: 0.6;
        margin-top: 3px;
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
        padding-top: 4px;
        border-top: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .memory-item:hover .memory-metadata {
        opacity: 0.85;
    }

    .metadata-tag {
        padding: 2px 6px;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 3px;
        font-size: 9px;
        color: rgba(255, 255, 255, 0.65);
        line-height: 1.3;
    }
    
    .metadata-tag.category {
        background: rgba(138, 43, 226, 0.2);
        color: #c084fc;
        border: 1px solid rgba(138, 43, 226, 0.25);
    }

    .metadata-tag.source {
        background: rgba(59, 130, 246, 0.15);
        color: #93c5fd;
        border: 1px solid rgba(59, 130, 246, 0.25);
    }

    .memory-bucket {
        margin-bottom: 10px;
        padding: 10px 12px;
        background: rgba(138, 43, 226, 0.08);
        border-radius: 8px;
        border: 1px solid rgba(138, 43, 226, 0.2);
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
    }
    
    .memory-bucket[data-bucket-type="general"] {
        background: rgba(59, 130, 246, 0.08);
        border-color: rgba(59, 130, 246, 0.2);
    }
    
    .memory-bucket[data-bucket-type="file"] {
        background: rgba(16, 185, 129, 0.08);
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .memory-bucket:hover {
        border-color: rgba(138, 43, 226, 0.35);
        background: rgba(138, 43, 226, 0.12);
    }
    
    .memory-bucket[data-bucket-type="general"]:hover {
        border-color: rgba(59, 130, 246, 0.35);
        background: rgba(59, 130, 246, 0.12);
    }
    
    .memory-bucket[data-bucket-type="file"]:hover {
        border-color: rgba(16, 185, 129, 0.35);
        background: rgba(16, 185, 129, 0.12);
    }

    .memory-bucket-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid rgba(138, 43, 226, 0.15);
        position: relative;
    }
    
    .memory-bucket-header::after {
        content: '';
        position: absolute;
        bottom: -1px;
        left: 0;
        width: 30px;
        height: 1px;
        background: rgba(138, 43, 226, 0.5);
        border-radius: 1px;
    }

    .memory-bucket-title {
        font-weight: 600;
        font-size: 12px;
        color: #c084fc;
        display: flex;
        align-items: center;
        gap: 6px;
        letter-spacing: -0.1px;
    }
    
    .memory-bucket[data-bucket-type="general"] .memory-bucket-title {
        color: #93c5fd;
    }
    
    .memory-bucket[data-bucket-type="file"] .memory-bucket-title {
        color: #6ee7b7;
    }

    .memory-bucket-count {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.6);
        margin-left: auto;
        padding: 2px 6px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 4px;
    }
    
    .memory-bucket-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: auto;
    }
    
    .bucket-file-count {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.1);
        padding: 3px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
    }
    
    .bucket-file-explorer-btn {
        padding: 6px 10px;
        font-size: 12px;
        background: rgba(138, 43, 226, 0.2);
        border: 1px solid rgba(138, 43, 226, 0.4);
        border-radius: 8px;
        color: #c084fc;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 4px;
        font-weight: 500;
    }
    
    .bucket-file-explorer-btn:hover {
        background: rgba(138, 43, 226, 0.3);
        border-color: rgba(138, 43, 226, 0.6);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(138, 43, 226, 0.3);
    }
    
    .memory-bucket[data-bucket-type="general"] .bucket-file-explorer-btn {
        background: rgba(59, 130, 246, 0.2);
        border-color: rgba(59, 130, 246, 0.4);
        color: #93c5fd;
    }
    
    .memory-bucket[data-bucket-type="general"] .bucket-file-explorer-btn:hover {
        background: rgba(59, 130, 246, 0.3);
        border-color: rgba(59, 130, 246, 0.6);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }
    
    .memory-bucket[data-bucket-type="file"] .bucket-file-explorer-btn {
        background: rgba(16, 185, 129, 0.2);
        border-color: rgba(16, 185, 129, 0.4);
        color: #6ee7b7;
    }
    
    .memory-bucket[data-bucket-type="file"] .bucket-file-explorer-btn:hover {
        background: rgba(16, 185, 129, 0.3);
        border-color: rgba(16, 185, 129, 0.6);
        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }
    
    .memory-bucket-count {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.6);
        font-weight: 600;
        padding: 2px 6px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 4px;
    }

    .memory-bucket-actions {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-left: auto;
    }
    
    .bucket-file-count {
        font-size: 9px;
        color: rgba(255, 255, 255, 0.55);
        background: rgba(255, 255, 255, 0.08);
        padding: 2px 6px;
        border-radius: 4px;
    }
    
    .bucket-file-explorer-btn {
        padding: 4px 8px;
        font-size: 10px;
        background: rgba(138, 43, 226, 0.15);
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 5px;
        color: #c084fc;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 3px;
        font-weight: 500;
    }
    
    .bucket-file-explorer-btn:hover {
        background: rgba(138, 43, 226, 0.25);
        border-color: rgba(138, 43, 226, 0.5);
    }
    
    .memory-bucket[data-bucket-type="general"] .bucket-file-explorer-btn {
        background: rgba(59, 130, 246, 0.15);
        border-color: rgba(59, 130, 246, 0.3);
        color: #93c5fd;
    }
    
    .memory-bucket[data-bucket-type="general"] .bucket-file-explorer-btn:hover {
        background: rgba(59, 130, 246, 0.25);
        border-color: rgba(59, 130, 246, 0.5);
    }
    
    .memory-bucket[data-bucket-type="file"] .bucket-file-explorer-btn {
        background: rgba(16, 185, 129, 0.15);
        border-color: rgba(16, 185, 129, 0.3);
        color: #6ee7b7;
    }
    
    .memory-bucket[data-bucket-type="file"] .bucket-file-explorer-btn:hover {
        background: rgba(16, 185, 129, 0.25);
        border-color: rgba(16, 185, 129, 0.5);
    }
    
    .memory-bucket .memory-item {
        margin-left: 0;
        margin-bottom: 4px;
        background: rgba(0, 0, 0, 0.2);
    }
    .memory-bucket .memory-item:last-child {
        margin-bottom: 0;
    }

    .empty-memory-state {
        text-align: center;
        padding: 40px 20px;
        opacity: 0.7;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
    }
    .empty-memory-state::before {
        content: "üí≠";
        font-size: 48px;
        opacity: 0.5;
    }
    .empty-memory-state.search-empty {
        padding: 30px 20px;
    }
    .empty-memory-state.search-empty::before {
        content: "üîç";
        font-size: 36px;
    }

    /* Raw Content Modal */
    .raw-content-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(8px);
        z-index: 50000;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.2s ease-out;
    }
    
    .raw-content-modal.active {
        display: flex !important;
        z-index: 50000 !important;
        pointer-events: auto;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    .raw-content-modal-content {
        background: linear-gradient(135deg, rgba(26, 27, 47, 0.98), rgba(20, 21, 38, 0.98));
        backdrop-filter: blur(20px);
        border: 1.5px solid rgba(138, 43, 226, 0.3);
        border-radius: 20px;
        width: 90%;
        max-width: 900px;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(138, 43, 226, 0.2) inset;
        animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
        position: relative;
        z-index: 50001;
        pointer-events: auto;
    }
    
    @keyframes slideUp {
        from {
            transform: translateY(30px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }
    
    .raw-content-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.15), rgba(99, 102, 241, 0.1));
    }
    
    .raw-content-modal-title {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 18px;
        font-weight: 700;
        color: #c084fc;
    }
    
    .raw-content-icon {
        font-size: 24px;
    }
    
    .raw-content-close-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: rgba(255, 255, 255, 0.9);
        font-size: 18px;
        transition: all 0.2s ease;
    }
    
    .raw-content-close-btn:hover {
        background: rgba(248, 81, 73, 0.2);
        border-color: rgba(248, 81, 73, 0.5);
        color: #f85149;
        transform: rotate(90deg);
    }
    
    .raw-content-modal-body {
        flex: 1;
        overflow: auto;
        padding: 24px;
        position: relative;
    }
    
    .raw-content-loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        color: rgba(255, 255, 255, 0.7);
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid rgba(138, 43, 226, 0.2);
        border-top-color: #c084fc;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-bottom: 16px;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .raw-content-error {
        text-align: center;
        padding: 60px 20px;
        color: #f85149;
        font-size: 16px;
    }
    
    .raw-content-text {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 20px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        color: rgba(255, 255, 255, 0.9);
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: calc(85vh - 200px);
        overflow: auto;
    }
    
    .raw-content-text::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }
    
    .raw-content-text::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
    }
    
    .raw-content-text::-webkit-scrollbar-thumb {
        background: rgba(138, 43, 226, 0.4);
        border-radius: 4px;
    }
    
    .raw-content-text::-webkit-scrollbar-thumb:hover {
        background: rgba(138, 43, 226, 0.6);
    }

    .memory-count-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        background: rgba(138, 43, 226, 0.2);
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 10px;
        font-size: 10px;
        color: #c084fc;
        margin-left: auto;
    }

    .memory-storage-indicator {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 16px;
        background: #8A2BE2;
        color: #fff;
        border-radius: 8px;
        font-size: 12px;
        display: none;
        align-items: center;
        gap: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
    }

    .memory-storage-indicator.show {
        display: flex;
    }

    @keyframes slideIn {
        from {
            transform: translateY(20px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    .mem0-ops-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        background: rgba(59, 130, 246, 0.2);
        border: 1px solid rgba(59, 130, 246, 0.5);
        border-radius: 12px;
        font-size: 11px;
        color: #93c5fd;
        margin-left: 8px;
    }

    .memory-context-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        background: rgba(16, 185, 129, 0.2);
        border: 1px solid rgba(16, 185, 129, 0.5);
        border-radius: 12px;
        font-size: 11px;
        color: #6ee7b7;
        margin-left: 8px;
    }

    /* Memory Navigator Modal */
    .memory-navigator-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(8px);
        z-index: 3000;
        transition: z-index 0s; /* Allow z-index changes */
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .memory-navigator-modal.show {
        display: flex;
        opacity: 1;
    }

    .memory-navigator-content {
        background: radial-gradient(circle at center, rgba(26, 27, 47, 0.98) 0%, rgba(26, 27, 47, 0.95) 100%);
        backdrop-filter: blur(24px);
        border: 1.5px solid rgba(138, 43, 226, 0.3);
        border-radius: 24px;
        padding: 0;
        width: 90%;
        max-width: 900px;
        max-height: 85vh;
        box-shadow: 0 20px 60px rgba(0,0,0,0.6), 0 0 0 1px rgba(138, 43, 226, 0.2) inset;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transform: scale(0.95);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .memory-navigator-modal.show .memory-navigator-content {
        transform: scale(1);
    }
    
    .memory-navigator-header {
        padding: 24px 28px;
        border-bottom: 2px solid rgba(138, 43, 226, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), transparent);
    }
    
    .memory-navigator-title {
        font-size: 22px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.98);
        display: flex;
        align-items: center;
        gap: 12px;
        letter-spacing: -0.5px;
    }
    
    .memory-navigator-title::before {
        content: "üß≠";
        font-size: 28px;
        filter: drop-shadow(0 2px 4px rgba(138, 43, 226, 0.4));
    }
    
    .memory-navigator-close {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: all 0.25s;
    }
    
    .memory-navigator-close:hover {
        background: rgba(248, 81, 73, 0.2);
        border-color: rgba(248, 81, 73, 0.4);
        color: #f85149;
        transform: rotate(90deg);
    }
    
    .memory-navigator-body {
        flex: 1;
        overflow-y: auto;
        padding: 24px 28px;
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 24px;
        min-height: 0;
    }
    
    .memory-navigator-sidebar {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    
    .memory-navigator-stats {
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.15), rgba(99, 102, 241, 0.1));
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 16px;
        padding: 20px;
    }
    
    .memory-navigator-stats-title {
        font-size: 13px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .memory-stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .memory-stat-item:last-child {
        border-bottom: none;
    }
    
    .memory-stat-label {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
    }
    
    .memory-stat-value {
        font-size: 16px;
        font-weight: 700;
        color: #c084fc;
    }
    
    .memory-navigator-buckets {
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-height: 400px;
        overflow-y: auto;
    }
    
    .memory-navigator-bucket-item {
        padding: 12px 16px;
        background: rgba(0, 0, 0, 0.3);
        border: 1.5px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.25s;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .memory-navigator-bucket-item:hover {
        background: rgba(138, 43, 226, 0.2);
        border-color: rgba(138, 43, 226, 0.4);
        transform: translateX(4px);
    }
    
    .memory-navigator-bucket-item.active {
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(99, 102, 241, 0.2));
        border-color: rgba(138, 43, 226, 0.6);
        box-shadow: 0 4px 12px rgba(138, 43, 226, 0.2);
    }
    
    .memory-navigator-main {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    
    .memory-navigator-search-section {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .memory-navigator-search {
        position: relative;
    }
    
    .memory-navigator-search input {
        width: 100%;
        padding: 14px 18px 14px 48px;
        background: rgba(0, 0, 0, 0.4);
        border: 1.5px solid rgba(255, 255, 255, 0.2);
        border-radius: 14px;
        color: #fff;
        font-size: 15px;
        transition: all 0.3s;
    }
    
    .memory-navigator-search input:focus {
        outline: none;
        border-color: rgba(138, 43, 226, 0.7);
        box-shadow: 0 0 0 4px rgba(138, 43, 226, 0.15);
        background: rgba(0, 0, 0, 0.5);
    }
    
    .memory-navigator-search-icon {
        position: absolute;
        left: 16px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 18px;
        opacity: 0.6;
    }
    
    .memory-navigator-search-info {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.5);
        padding: 0 4px;
    }
    
    .memory-navigator-results {
        flex: 1;
        overflow-y: auto;
        min-height: 300px;
        max-height: 500px;
    }
    
    .memory-navigator-raw-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    .memory-navigator-raw-content-header {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 16px 20px;
        border-bottom: 1px solid rgba(138, 43, 226, 0.2);
        background: rgba(0, 0, 0, 0.2);
    }
    
    .memory-navigator-back-btn {
        background: rgba(138, 43, 226, 0.2);
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 8px;
        padding: 8px 16px;
        color: #c084fc;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
    }
    
    .memory-navigator-back-btn:hover {
        background: rgba(138, 43, 226, 0.3);
        border-color: rgba(138, 43, 226, 0.5);
        transform: translateX(-2px);
    }
    
    .memory-navigator-raw-content-title {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 18px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.95);
        flex: 1;
    }
    
    .memory-navigator-raw-content-body {
        flex: 1;
        overflow: auto;
        padding: 24px;
    }
    
    .memory-navigator-raw-content-body .raw-content-text {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 20px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
        font-size: 13px;
        line-height: 1.6;
        color: rgba(255, 255, 255, 0.9);
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow: auto;
        height: 100%;
    }
    
    .memory-navigator-raw-content-body .raw-content-loading,
    .memory-navigator-raw-content-body .raw-content-error {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px;
        text-align: center;
        color: rgba(255, 255, 255, 0.7);
    }
    
    .memory-navigator-raw-content-body .raw-content-error {
        color: rgba(248, 81, 73, 0.8);
    }

    /* File Explorer Modal */
    .file-explorer-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(8px);
        z-index: 3001;
        transition: z-index 0s; /* Allow z-index changes */
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .file-explorer-modal.show {
        display: flex;
        opacity: 1;
    }

    .file-explorer-content {
        background: radial-gradient(circle at center, rgba(26, 27, 47, 0.98) 0%, rgba(26, 27, 47, 0.95) 100%);
        backdrop-filter: blur(24px);
        border: 1.5px solid rgba(138, 43, 226, 0.3);
        border-radius: 24px;
        padding: 0;
        width: 90%;
        max-width: 800px;
        max-height: 85vh;
        box-shadow: 0 20px 60px rgba(0,0,0,0.6), 0 0 0 1px rgba(138, 43, 226, 0.2) inset;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transform: scale(0.95);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .file-explorer-modal.show .file-explorer-content {
        transform: scale(1);
    }
    
    .file-explorer-header {
        padding: 24px 28px;
        border-bottom: 2px solid rgba(138, 43, 226, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), transparent);
    }
    
    .file-explorer-title {
        font-size: 22px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.98);
        display: flex;
        align-items: center;
        gap: 12px;
        letter-spacing: -0.5px;
    }
    
    .file-explorer-title span:first-child {
        font-size: 28px;
        filter: drop-shadow(0 2px 4px rgba(138, 43, 226, 0.4));
    }
    
    .file-explorer-close {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: all 0.25s;
    }
    
    .file-explorer-close:hover {
        background: rgba(248, 81, 73, 0.2);
        border-color: rgba(248, 81, 73, 0.4);
        color: #f85149;
        transform: rotate(90deg);
    }
    
    .file-explorer-body {
        flex: 1;
        overflow-y: auto;
        padding: 24px 28px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        min-height: 0;
    }
    
    .file-explorer-search {
        position: relative;
    }
    
    .file-explorer-search input {
        width: 100%;
        padding: 14px 18px 14px 48px;
        background: rgba(0, 0, 0, 0.4);
        border: 1.5px solid rgba(255, 255, 255, 0.2);
        border-radius: 14px;
        color: #fff;
        font-size: 15px;
        transition: all 0.3s;
    }
    
    .file-explorer-search input:focus {
        outline: none;
        border-color: rgba(138, 43, 226, 0.7);
        box-shadow: 0 0 0 4px rgba(138, 43, 226, 0.15);
        background: rgba(0, 0, 0, 0.5);
    }
    
    .file-explorer-search-icon {
        position: absolute;
        left: 16px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 18px;
        opacity: 0.6;
    }
    
    .file-explorer-upload-area {
        border: 2px dashed rgba(138, 43, 226, 0.4);
        border-radius: 16px;
        padding: 40px;
        text-align: center;
        background: rgba(138, 43, 226, 0.05);
        transition: all 0.3s ease;
        cursor: pointer;
    }
    
    .file-explorer-upload-area:hover {
        border-color: rgba(138, 43, 226, 0.6);
        background: rgba(138, 43, 226, 0.1);
    }
    
    .file-explorer-upload-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
    }
    
    .file-explorer-upload-icon {
        font-size: 48px;
        opacity: 0.7;
    }
    
    .file-explorer-upload-text {
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
    }
    
    .file-explorer-upload-btn {
        padding: 10px 20px;
        background: rgba(138, 43, 226, 0.3);
        border: 1px solid rgba(138, 43, 226, 0.5);
        border-radius: 10px;
        color: #c084fc;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s ease;
    }
    
    .file-explorer-upload-btn:hover {
        background: rgba(138, 43, 226, 0.4);
        border-color: rgba(138, 43, 226, 0.7);
        transform: translateY(-2px);
    }
    
    .file-explorer-list {
        flex: 1;
        overflow-y: auto;
        min-height: 200px;
        max-height: 400px;
    }
    
    .file-explorer-item {
        padding: 14px 16px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .file-explorer-item:hover {
        background: rgba(138, 43, 226, 0.15);
        border-color: rgba(138, 43, 226, 0.3);
        transform: translateX(4px);
    }
    
    .file-explorer-item-info {
        display: flex;
        align-items: center;
        gap: 12px;
        flex: 1;
    }
    
    .file-explorer-item-icon {
        font-size: 24px;
    }
    
    .file-explorer-item-details {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    
    .file-explorer-item-name {
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
        font-size: 14px;
    }
    
    .file-explorer-item-meta {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.5);
    }
    
    .file-explorer-item-actions {
        display: flex;
        gap: 8px;
    }
    
    .file-explorer-action-btn {
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
    }
    
    .file-explorer-action-btn:hover {
        background: rgba(255, 255, 255, 0.15);
        border-color: rgba(255, 255, 255, 0.25);
    }
    
    .file-explorer-action-btn.remove {
        background: rgba(248, 81, 73, 0.15);
        border-color: rgba(248, 81, 73, 0.3);
        color: #f85149;
    }
    
    .file-explorer-action-btn.remove:hover {
        background: rgba(248, 81, 73, 0.25);
        border-color: rgba(248, 81, 73, 0.5);
    }

    /* Category Modal */
    .category-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(5px);
        z-index: 2000;
        align-items: center;
        justify-content: center;
    }

    .category-modal.show {
        display: flex;
    }

    .category-modal-content {
        background: radial-gradient(circle at center, rgba(26, 27, 47, 0.95) 0%, rgba(26, 27, 47, 0.9) 100%);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        padding: 30px;
        min-width: 300px;
        max-width: 90%;
        box-shadow: 0 15px 40px rgba(0,0,0,0.5);
    }

    .category-modal-title {
        font-weight: 600;
        margin-bottom: 15px;
        font-size: 18px;
        color: rgba(255, 255, 255, 0.9);
    }

    .category-modal-input {
        width: 100%;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        color: #fff;
        font-size: 14px;
        margin-bottom: 15px;
    }

    .category-modal-input:focus {
        outline: none;
        border-color: rgba(138, 43, 226, 0.5);
        box-shadow: 0 0 15px rgba(138, 43, 226, 0.3);
    }

    .category-modal-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
    }

    .category-modal-actions button {
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
    }

    .category-modal-actions .btn-primary {
        background: #8A2BE2;
        color: #fff;
    }

    .category-modal-actions .btn-primary:hover {
        background: #9932CC;
    }

    .category-modal-actions .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .category-modal-actions .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.15);
    }

    /* WebSocket Connecting Overlay */
    .websocket-connecting-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 1;
        transition: opacity 0.3s ease;
    }
    
    .websocket-connecting-overlay.hidden {
        opacity: 0;
        pointer-events: none;
    }
    
    .websocket-connecting-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
        text-align: center;
        padding: 40px;
    }
    
    .websocket-connecting-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(138, 43, 226, 0.2);
        border-top-color: #c084fc;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    .websocket-connecting-text {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .websocket-connecting-title {
        font-size: 20px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.95);
    }
    
    .websocket-connecting-subtitle {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
    }
    
    .conversation-container.disabled {
        pointer-events: none;
        opacity: 0.5;
        filter: blur(2px);
        transition: all 0.3s ease;
    }
    
    .conversation-container.disabled * {
        cursor: not-allowed !important;
    }

    /* Responsive */
    @media (max-width: 768px) {
        .conversation-container {
            flex-direction: column;
            height: calc(100vh - 80px);
            max-height: none;
        }
        
        .memory-sidebar {
            width: 100%;
            max-height: 300px;
        }
        
        .conversation-main {
            flex: 1;
            min-height: 0;
        }
        
        .memory-navigator-content {
            width: 95%;
            max-height: 90vh;
        }
        
        .memory-navigator-body {
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .memory-navigator-sidebar {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .memory-nav-btn span:last-child {
            display: none;
        }
    }
</style>
{% endblock %}

{% block back_button %}{% endblock %}

{% block content %}
<div class="drag-drop-overlay" id="drag-drop-overlay">
    <div class="drag-drop-content">Drop files here to upload</div>
</div>

<div class="websocket-connecting-overlay" id="websocket-connecting-overlay">
    <div class="websocket-connecting-content">
        <div class="websocket-connecting-spinner"></div>
        <div class="websocket-connecting-text">
            <div class="websocket-connecting-title">Connecting to Orby...</div>
            <div class="websocket-connecting-subtitle">Please wait while we establish a secure connection</div>
        </div>
    </div>
</div>

<div class="conversation-container" id="conversation-container">
    <div class="conversation-main" id="chat-console">
        <a href="/conversations" id="back-to-conversations-btn" title="Back to Conversations">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
            </svg>
            <span>Back</span>
        </a>
        <div id="orb"></div>
        
        <div class="conversation-header">
            <div class="conversation-title">{{ conversation.title }}</div>
            <button onclick="deleteConversation()" style="background: rgba(248, 81, 73, 0.2); color: #f85149; border: 1px solid rgba(248, 81, 73, 0.3); padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">Delete</button>
        </div>

        <div class="conversation-messages" id="messages-container">
            {% for message in messages %}
            <div class="message {{ message.role }}">
                {% if message.role == 'user' %}
                <svg class="avatar" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <path d="M50,4A46,46,0,1,1,4,50,46,46,0,0,1,50,4m0-4a50,50,0,1,0,50,50A50,50,0,0,0,50,0Z"/>
                    <path d="M50,62.5a18.75,18.75,0,1,1,18.75-18.75A18.77,18.77,0,0,1,50,62.5Z"/>
                </svg>
                {% else %}
                <svg class="avatar" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="45" stroke="currentColor" stroke-width="5" fill="none" opacity="0.5"/>
                    <circle cx="50" cy="50" r="30" fill="currentColor"/>
                    <circle cx="50" cy="50" r="15" fill="#1a1b2f"/>
                </svg>
                {% endif %}
                <div class="message-content">
                    <div class="text">{{ message.content }}</div>
                    <div class="message-time">
                        {{ message.created_at.strftime('%Y-%m-%d %H:%M') if message.created_at else 'N/A' }}
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>

        <div class="conversation-input" id="conversation-input-area">
            <div id="file-preview-container"></div>
            <form id="message-form" onsubmit="sendMessage(event)" enctype="multipart/form-data">
                <div class="input-form">
                    <label for="file-input" id="file-upload-btn" title="Upload file (or drag & drop)">
                        üìé
                    </label>
                    <input type="file" id="file-input" multiple accept=".txt,.text,.md,.markdown,.html,.htm,.php,.py,.js,.ts,.css,.java,.c,.cpp,.cs,.rb,.go,.rs,.kt,.swift,.xml,.json,.sh,.pl,.r,.sql,.yml,.yaml,.toml,.bat,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.csv">
                    <select id="category-select" class="category-select-input" title="Select category for this message">
                        <option value="general">General</option>
                        <option value="work">Work</option>
                        <option value="coding">Coding</option>
                        <option value="personal">Personal</option>
                        <option value="creative">Creative</option>
                    </select>
                    <input
                        type="text"
                        id="message-input"
                        placeholder="Message Orby..."
                        autocomplete="off"
                    >
                    <button type="submit" class="btn" id="send-btn">‚û§</button>
                </div>
            </form>
        </div>
    </div>

    <div id="raw-content-modal" class="raw-content-modal" onclick="if(event.target === this) closeRawContentModal()">
        <div class="raw-content-modal-content">
            <div class="raw-content-modal-header">
                <div class="raw-content-modal-title">
                    <span class="raw-content-icon">üìÑ</span>
                    <span id="raw-content-filename">Source Document</span>
                    <span style="font-size: 13px; font-weight: 400; color: rgba(255,255,255,0.6); margin-left: 12px;">View the full document that generated this memory</span>
                </div>
                <button class="raw-content-close-btn" onclick="closeRawContentModal()" title="Close">‚úï</button>
            </div>
            <div class="raw-content-modal-body">
                <div id="raw-content-loading" class="raw-content-loading">
                    <div class="loading-spinner"></div>
                    <p>Loading source content...</p>
                </div>
                <div id="raw-content-error" class="raw-content-error" style="display: none;">
                    <p>‚ùå Could not load source content</p>
                </div>
                <pre id="raw-content-text" class="raw-content-text" style="display: none;"></pre>
            </div>
        </div>
    </div>

    <div class="memory-sidebar">
        <div class="memory-panel">
            <div class="memory-panel-header">
                <div class="memory-panel-title">
                    Active Context
                    <span class="memory-context-indicator" title="Shows memories retrieved by AI for the current response">üîç</span>
                    <span class="connection-status" id="connection-status" title="Connection status">
                        <span class="connection-dot" id="connection-dot"></span>
                    </span>
                </div>
                <div class="memory-panel-actions">
                    <button class="memory-nav-btn" onclick="showMemoryNavigator()" title="Open Memory Navigator">
                        <span>üß≠</span>
                        <span>Navigate</span>
                    </button>
                </div>
            </div>

            <!-- Simplified: Just show active context buckets, search moved to Memory Navigator -->

            <div id="memory-context-list" data-context-type="active">
                <div class="empty-memory-state">Active Context will show memories retrieved by the AI for each response. Send a message to see retrieved memories.</div>
                <div class="empty-memory-state">No active memories yet. Start chatting to build context!</div>
            </div>
        </div>

    </div>
</div>

<div class="memory-storage-indicator" id="memory-storage-indicator">
    Memory stored successfully
</div>

<div class="memory-navigator-modal" id="memory-navigator-modal">
    <div class="memory-navigator-content">
        <div class="memory-navigator-header">
            <div class="memory-navigator-title">Memory Navigator</div>
            <button class="memory-navigator-close" onclick="hideMemoryNavigator()">‚úï</button>
        </div>
        <div class="memory-navigator-body">
            <div class="memory-navigator-sidebar">
                <div class="memory-navigator-stats">
                    <div class="memory-navigator-stats-title">Statistics</div>
                    <div class="memory-stat-item">
                        <span class="memory-stat-label">Total Memories</span>
                        <span class="memory-stat-value" id="nav-total-memories">0</span>
                    </div>
                    <div class="memory-stat-item">
                        <span class="memory-stat-label">Buckets</span>
                        <span class="memory-stat-value" id="nav-total-buckets">0</span>
                    </div>
                    <div class="memory-stat-item">
                        <span class="memory-stat-label">File Buckets</span>
                        <span class="memory-stat-value" id="nav-file-buckets">0</span>
                    </div>
                    <div class="memory-stat-item">
                        <span class="memory-stat-label">General Buckets</span>
                        <span class="memory-stat-value" id="nav-general-buckets">0</span>
                    </div>
                </div>
                <div class="memory-navigator-buckets" id="memory-navigator-buckets-list">
                    <div style="padding: 20px; text-align: center; color: rgba(255,255,255,0.5);">Loading buckets...</div>
                </div>
            </div>
            <div class="memory-navigator-main">
                <div class="memory-navigator-search-section">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <div class="memory-navigator-search" style="flex: 1;">
                            <input 
                                type="text" 
                                id="nav-search-input" 
                                placeholder="Search all memories or within selected bucket..."
                                onkeyup="navigatorSearch(event)"
                            >
                            <span class="memory-navigator-search-icon">üîç</span>
                        </div>
                    </div>
                    <div class="memory-navigator-search-info" id="nav-search-info">
                        <span id="nav-search-mode">Select a bucket or search all memories</span>
                    </div>
                </div>
                <div class="memory-navigator-results" id="memory-navigator-results">
                    <div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);">
                        <div style="font-size: 48px; margin-bottom: 16px;">üß≠</div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Select a bucket to explore</div>
                        <div style="font-size: 13px;">Choose a bucket from the sidebar or search all memories</div>
                    </div>
                </div>
                <!-- Raw Content View (hidden by default) -->
                <div class="memory-navigator-raw-content" id="memory-navigator-raw-content" style="display: none;">
                    <div class="memory-navigator-raw-content-header">
                        <button class="memory-navigator-back-btn" onclick="showMemoryNavigatorResults()" title="Back to memories">
                            <span>‚Üê</span> Back
                        </button>
                        <div class="memory-navigator-raw-content-title">
                            <span class="raw-content-icon">üìÑ</span>
                            <span id="nav-raw-content-filename">Source Document</span>
                        </div>
                    </div>
                    <div class="memory-navigator-raw-content-body">
                        <div id="nav-raw-content-loading" class="raw-content-loading">
                            <div class="loading-spinner"></div>
                            <p>Loading source content...</p>
                        </div>
                        <div id="nav-raw-content-error" class="raw-content-error" style="display: none;">
                            <p>‚ùå Could not load source content</p>
                        </div>
                        <pre id="nav-raw-content-text" class="raw-content-text" style="display: none;"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="file-explorer-modal" id="file-explorer-modal">
    <div class="file-explorer-content">
        <div class="file-explorer-header">
            <div class="file-explorer-title">
                <span>üìÅ</span>
                <span id="file-explorer-bucket-name">File Explorer</span>
            </div>
            <button class="file-explorer-close" onclick="hideFileExplorer()">‚úï</button>
        </div>
        <div class="file-explorer-body">
            <div class="file-explorer-search">
                <input 
                    type="text" 
                    id="file-explorer-search-input" 
                    placeholder="Search files..."
                    onkeyup="filterBucketFiles(event)"
                >
                <span class="file-explorer-search-icon">üîç</span>
            </div>
            <div class="file-explorer-upload-area" id="file-explorer-upload-area" ondrop="handleFileExplorerDrop(event)" ondragover="event.preventDefault()" ondragenter="event.preventDefault()">
                <div class="file-explorer-upload-content">
                    <div class="file-explorer-upload-icon">üì§</div>
                    <div class="file-explorer-upload-text">Drag & drop files here or</div>
                    <label for="file-explorer-file-input" class="file-explorer-upload-btn">Browse Files</label>
                    <input type="file" id="file-explorer-file-input" multiple style="display: none;" onchange="handleFileExplorerFileSelect(event)">
                </div>
            </div>
            <div class="file-explorer-list" id="file-explorer-list">
                <div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);">
                    <div style="font-size: 48px; margin-bottom: 16px;">üìÅ</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Loading files...</div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="category-modal" id="category-modal">
    <div class="category-modal-content">
        <div class="category-modal-title">Add Custom Category</div>
        <input 
            type="text" 
            id="new-category-input" 
            class="category-modal-input" 
            placeholder="Enter category name (e.g., 'research', 'meetings')"
            maxlength="50"
            onkeypress="handleCategoryInputKeypress(event)"
        >
        <div class="category-modal-actions">
            <button class="btn-secondary" onclick="hideAddCategoryModal()">Cancel</button>
            <button class="btn-primary" onclick="addCustomCategory()">Add Category</button>
        </div>
    </div>
</div>

<script>
const conversationId = '{{ conversation._id }}';
let activeMemoryContext = [];
let memoryRefreshRetryCount = 0;
let isWaitingForNewMemories = false;
const MAX_MEMORY_RETRY_ATTEMPTS = 50; // Much higher limit - don't give up easily
const MEMORY_RETRY_DELAYS = [
    10000, 15000, 20000, 25000, 30000,  // First 5 retries: 10s, 15s, 20s, 25s, 30s
    35000, 40000, 45000, 50000, 55000,  // Next 5: 35s, 40s, 45s, 50s, 55s
    60000, 60000, 60000, 60000, 60000, // Then every 60s for remaining attempts
    60000, 60000, 60000, 60000, 60000,
    60000, 60000, 60000, 60000, 60000,
    60000, 60000, 60000, 60000, 60000,
    60000, 60000, 60000, 60000, 60000,
    60000, 60000, 60000, 60000, 60000,
    60000, 60000, 60000, 60000, 60000
];
const MEMORY_EXTRACTION_TIMEOUT = 300000; // 5 minutes - then show abort option
let bucketFilesData = {}; // Store bucket files data globally

// File upload state
let selectedFiles = [];
const MAX_FILE_SIZE = 50 * 1024 * 1024; // Increased to 50MB
// Allowed types
const ALLOWED_FILE_TYPES = [
    // Text/Code
    'text/plain', 'text/markdown', 'text/html', 'text/css', 'text/javascript', 'application/json', 'application/xml',
    // Documents
    'application/pdf', 
    'application/msword', 
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // docx
    'application/vnd.ms-excel', 
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // xlsx
    'application/vnd.ms-powerpoint',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation', // pptx
    'text/csv'
];

// Category management
const DEFAULT_CATEGORIES = ['general', 'work', 'coding', 'personal', 'creative'];
const CATEGORIES_STORAGE_KEY = 'sso_app_3_custom_categories';

function getCustomCategories() {
    try {
        const stored = localStorage.getItem(CATEGORIES_STORAGE_KEY);
        return stored ? JSON.parse(stored) : [];
    } catch (e) {
        console.error('Failed to load custom categories:', e);
        return [];
    }
}

function saveCustomCategories(categories) {
    try {
        localStorage.setItem(CATEGORIES_STORAGE_KEY, JSON.stringify(categories));
    } catch (e) {
        console.error('Failed to save custom categories:', e);
    }
}

function getAllCategories() {
    return [...DEFAULT_CATEGORIES, ...getCustomCategories()];
}

function populateCategorySelect() {
    const select = document.getElementById('category-select');
    if (!select) return;
    
    const allCategories = getAllCategories();
    const currentValue = select.value; // Preserve current selection
    
    // Clear and rebuild options
    select.innerHTML = '';
    
    allCategories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
        select.appendChild(option);
    });
    
    // Restore selection if it still exists
    if (currentValue && allCategories.includes(currentValue)) {
        select.value = currentValue;
    }
}

function showAddCategoryModal() {
    const modal = document.getElementById('category-modal');
    const input = document.getElementById('new-category-input');
    if (modal && input) {
        modal.classList.add('show');
        input.value = '';
        input.focus();
    }
}

function hideAddCategoryModal() {
    const modal = document.getElementById('category-modal');
    if (modal) {
        modal.classList.remove('show');
    }
}

function handleCategoryInputKeypress(event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        addCustomCategory();
    } else if (event.key === 'Escape') {
        hideAddCategoryModal();
    }
}

function addCustomCategory() {
    const input = document.getElementById('new-category-input');
    if (!input) return;
    
    const categoryName = input.value.trim().toLowerCase();
    
    if (!categoryName) {
        alert('Please enter a category name');
        return;
    }
    
    if (categoryName.length < 2) {
        alert('Category name must be at least 2 characters');
        return;
    }
    
    if (categoryName.length > 50) {
        alert('Category name must be less than 50 characters');
        return;
    }
    
    const allCategories = getAllCategories();
    if (allCategories.includes(categoryName)) {
        alert('This category already exists');
        return;
    }
    
    if (!/^[a-z0-9\s\-_]+$/.test(categoryName)) {
        alert('Category name can only contain letters, numbers, spaces, hyphens, and underscores');
        return;
    }
    
    const customCategories = getCustomCategories();
    customCategories.push(categoryName);
    saveCustomCategories(customCategories);
    
    populateCategorySelect();
    
    const select = document.getElementById('category-select');
    if (select) {
        select.value = categoryName;
        applyMetadataFilter();
    }
    
    hideAddCategoryModal();
}

// Helper to read cookies for CSRF token
function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return '';
}

function scrollToBottom() {
    const container = document.getElementById('messages-container');
    container.scrollTop = container.scrollHeight;
}

// WebSocket connection logic
let memoryWebSocket = null;
let wsReconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
let isWebSocketConnected = false;
let isConnecting = false;

function setConnectionState(connected, connecting) {
    isWebSocketConnected = connected;
    isConnecting = connecting;
    
    const overlay = document.getElementById('websocket-connecting-overlay');
    const container = document.getElementById('conversation-container');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const fileInput = document.getElementById('file-input');
    const fileUploadBtn = document.getElementById('file-upload-btn');
    const categorySelect = document.getElementById('category-select');
    const connectionDot = document.getElementById('connection-dot');
    
    // Update connection status indicator
    if (connectionDot) {
        connectionDot.classList.remove('connected', 'connecting');
        if (connected) {
            connectionDot.classList.add('connected');
            connectionDot.title = 'Connected';
        } else if (connecting) {
            connectionDot.classList.add('connecting');
            connectionDot.title = 'Connecting...';
        } else {
            connectionDot.title = 'Disconnected';
        }
    }
    
    if (connected) {
        // Connected - enable everything
        if (overlay) overlay.classList.add('hidden');
        if (container) container.classList.remove('disabled');
        if (messageInput) {
            messageInput.disabled = false;
            messageInput.placeholder = 'Message Orby...';
        }
        if (sendBtn) {
            sendBtn.disabled = false;
            sendBtn.title = 'Send message';
        }
        if (fileInput) fileInput.disabled = false;
        if (fileUploadBtn) {
            fileUploadBtn.style.pointerEvents = 'auto';
            fileUploadBtn.style.opacity = '1';
            fileUploadBtn.title = 'Upload file (or drag & drop)';
        }
        if (categorySelect) categorySelect.disabled = false;
    } else if (connecting) {
        // Connecting - disable everything
        if (overlay) {
            overlay.classList.remove('hidden');
            const title = overlay.querySelector('.websocket-connecting-title');
            const subtitle = overlay.querySelector('.websocket-connecting-subtitle');
            if (title) title.textContent = 'Connecting to Orby...';
            if (subtitle) subtitle.textContent = 'Please wait while we establish a secure connection';
        }
        if (container) container.classList.add('disabled');
        if (messageInput) {
            messageInput.disabled = true;
            messageInput.placeholder = 'Connecting...';
        }
        if (sendBtn) {
            sendBtn.disabled = true;
            sendBtn.title = 'Waiting for connection...';
        }
        if (fileInput) fileInput.disabled = true;
        if (fileUploadBtn) {
            fileUploadBtn.style.pointerEvents = 'none';
            fileUploadBtn.style.opacity = '0.5';
            fileUploadBtn.title = 'Waiting for connection...';
        }
        if (categorySelect) categorySelect.disabled = true;
    } else {
        // Disconnected - show error state but allow reconnection attempts
        if (overlay) {
            overlay.classList.remove('hidden');
            const title = overlay.querySelector('.websocket-connecting-title');
            const subtitle = overlay.querySelector('.websocket-connecting-subtitle');
            if (title) title.textContent = 'Connection Lost';
            if (subtitle) subtitle.textContent = 'Attempting to reconnect...';
        }
        if (container) container.classList.add('disabled');
        if (messageInput) {
            messageInput.disabled = true;
            messageInput.placeholder = 'Connection lost - reconnecting...';
        }
        if (sendBtn) {
            sendBtn.disabled = true;
            sendBtn.title = 'Connection lost - reconnecting...';
        }
        if (fileInput) fileInput.disabled = true;
        if (fileUploadBtn) {
            fileUploadBtn.style.pointerEvents = 'none';
            fileUploadBtn.style.opacity = '0.5';
            fileUploadBtn.title = 'Connection lost - reconnecting...';
        }
        if (categorySelect) categorySelect.disabled = true;
    }
}

function connectMemoryWebSocket() {
    // Don't block if already connected
    if (isWebSocketConnected && memoryWebSocket && memoryWebSocket.readyState === WebSocket.OPEN) {
        console.log('WebSocket already connected');
        return;
    }
    
    // If already connecting and socket exists, wait for it to complete or timeout
    if (isConnecting && memoryWebSocket) {
        const currentState = memoryWebSocket.readyState;
        if (currentState === WebSocket.CONNECTING) {
            console.log('WebSocket connection already in progress, waiting...');
            return;
        }
        // If socket exists but not connecting, clean it up
        if (currentState === WebSocket.CLOSED || currentState === WebSocket.CLOSING) {
            memoryWebSocket = null;
            isConnecting = false;
        }
    }
    
    try {
        isConnecting = true;
        setConnectionState(false, true);
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws`;

        console.log('üîå Connecting to memory WebSocket:', wsUrl);
        console.log('   Current connection state:', {
            isConnecting,
            isWebSocketConnected,
            wsReconnectAttempts,
            previousSocket: memoryWebSocket ? memoryWebSocket.readyState : 'none'
        });
        
        // Set connection timeout (8 seconds - shorter than safety timeout)
        const connectionTimeout = setTimeout(() => {
            if (memoryWebSocket && memoryWebSocket.readyState === WebSocket.CONNECTING) {
                console.error('‚è±Ô∏è WebSocket connection timeout after 8 seconds');
                try {
                    memoryWebSocket.close();
                } catch (e) {
                    console.error('Error closing timed-out socket:', e);
                }
                memoryWebSocket = null;
                isConnecting = false;
                
                // Try to reconnect or fallback
                if (wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    wsReconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts), 10000);
                    console.log(`üîÑ Connection timeout. Retrying in ${delay}ms (attempt ${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                    
                    // Update overlay message
                    const overlay = document.getElementById('websocket-connecting-overlay');
                    if (overlay) {
                        const subtitle = overlay.querySelector('.websocket-connecting-subtitle');
                        if (subtitle) subtitle.textContent = `Connection timeout. Retrying... (attempt ${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`;
                    }
                    
                    setTimeout(() => {
                        connectMemoryWebSocket();
                    }, delay);
                } else {
                    console.error('‚ùå Max reconnection attempts reached. Falling back to polling.');
                    startPollingFallback();
                    setConnectionState(true, false); // Enable UI for polling fallback
                }
            }
        }, 8000); // 8 second timeout
        
        memoryWebSocket = new WebSocket(wsUrl);

        memoryWebSocket.onopen = () => {
            clearTimeout(connectionTimeout);
            console.log('‚úÖ Memory WebSocket connected successfully!');
            wsReconnectAttempts = 0;
            isConnecting = false;
            setConnectionState(true, false);
        };

        memoryWebSocket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('üì® WebSocket message received:', data.type, data.stage || '', data.message || '');
                handleWebSocketMessage(data);
            } catch (error) {
                console.error('Failed to parse WebSocket message:', error, event.data);
            }
        };

        memoryWebSocket.onerror = (error) => {
            clearTimeout(connectionTimeout);
            console.error('‚ùå WebSocket error:', error);
            console.error('   Socket state:', memoryWebSocket ? memoryWebSocket.readyState : 'null');
            // Don't set state here - let onclose handle it
            // This prevents double state updates
            // But update overlay to show error
            const overlay = document.getElementById('websocket-connecting-overlay');
            if (overlay) {
                const subtitle = overlay.querySelector('.websocket-connecting-subtitle');
                if (subtitle) subtitle.textContent = 'Connection error. Will retry...';
            }
        };
        
        memoryWebSocket.onclose = (event) => {
            clearTimeout(connectionTimeout);
            console.log('üîå Memory WebSocket disconnected', {
                code: event.code,
                reason: event.reason || 'No reason provided',
                wasClean: event.wasClean,
                attempts: wsReconnectAttempts
            });
            
            const wasConnected = isWebSocketConnected;
            memoryWebSocket = null;
            isConnecting = false;
            
            // Only show disconnected state if we were previously connected
            // Otherwise we're still in initial connection phase
            if (wasConnected) {
                setConnectionState(false, false);
            }
            
            // If it was a clean close (code 1000) or we've exceeded attempts, use fallback
            if (event.code === 1000 || wsReconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                console.log('‚ö†Ô∏è WebSocket closed cleanly or max attempts reached. Using fallback.');
                startPollingFallback();
                const overlay = document.getElementById('websocket-connecting-overlay');
                if (overlay) {
                    const title = overlay.querySelector('.websocket-connecting-title');
                    const subtitle = overlay.querySelector('.websocket-connecting-subtitle');
                    if (title) title.textContent = 'Connection Unavailable';
                    if (subtitle) subtitle.textContent = 'Using fallback mode. Some features may be limited.';
                    setTimeout(() => {
                        setConnectionState(true, false); // Enable UI for polling fallback
                    }, 2000);
                }
            } else {
                // Attempt reconnection
                wsReconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts), 10000);
                console.log(`üîÑ Reconnecting in ${delay}ms (attempt ${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                
                // Update overlay message
                const overlay = document.getElementById('websocket-connecting-overlay');
                if (overlay) {
                    const subtitle = overlay.querySelector('.websocket-connecting-subtitle');
                    if (subtitle) subtitle.textContent = `Reconnecting... (attempt ${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`;
                }
                
                setTimeout(() => {
                    connectMemoryWebSocket();
                }, delay);
            }
        };
    } catch (error) {
        console.error('Failed to create WebSocket connection:', error);
        isConnecting = false;
        setConnectionState(false, false);
        
        // Try fallback immediately
        startPollingFallback();
        setTimeout(() => {
            setConnectionState(true, false);
        }, 1000);
    }
}

function handleWebSocketMessage(data) {
    console.log('üîî handleWebSocketMessage called:', data.type, data.stage || '', data.message?.substring(0, 50) || '');
    
    if (data.type === 'memory_progress') {
        // Mark extraction as in progress
        memoryExtractionInProgress = true;
        lastMemoryProgressTime = Date.now();
        memoryRefreshAborted = false;
        
        console.log('üìä Memory progress event:', {
            stage: data.stage,
            message: data.message,
            progress: data.progress,
            filename: data.filename,
            fact_number: data.fact_number,
            total_facts: data.total_facts
        });
        
        // Reset timeout
        if (memoryExtractionTimeout) {
            clearTimeout(memoryExtractionTimeout);
        }
        memoryExtractionTimeout = setTimeout(() => {
            // Show abort button if no progress for timeout period
            if (memoryExtractionInProgress && memoryLoadingModal) {
                const abortBtn = memoryLoadingModal.querySelector('#memory-loading-abort-btn');
                if (abortBtn) {
                    abortBtn.style.display = 'inline-flex';
                }
            }
        }, MEMORY_EXTRACTION_TIMEOUT);
        
        // Update loading modal with progress updates
        const stage = data.stage || 'processing';
        const message = data.message || 'Processing...';
        const progress = data.progress !== undefined ? data.progress : null;
        const filename = data.filename;
        
        // Map stages to progress percentages if not provided
        let progressPercent = progress;
        if (progressPercent === null) {
            const stageProgress = {
                'starting': 5,
                'extracting_facts': 20,
                'storing_chat': 30,
                'storing_memories': 50,  // Base progress, will be updated with actual fact progress
                'generating_embeddings': 70,
                'raw_content_stored': 85,
                'error': null
            };
            progressPercent = stageProgress[stage] || null;
        }
        
        // For storing_memories stage, use more granular progress if fact_number is provided
        if (stage === 'storing_memories' && data.fact_number && data.total_facts) {
            // Calculate progress: 30% (storing_chat) to 70% (generating_embeddings)
            // So storing_memories takes 30-70% = 40% of total progress
            const baseProgress = 30;
            const stageRange = 40; // 70 - 30
            const factProgress = (data.fact_number / data.total_facts) * stageRange;
            progressPercent = baseProgress + factProgress;
        }
        
        // Ensure modal is shown (it should already be shown, but ensure it's visible)
        console.log('üîÑ Updating modal:', {
            hasModal: !!memoryLoadingModal,
            message: message.substring(0, 50),
            progress: progressPercent,
            stage: stage
        });
        
        // Always update modal - showMemoryLoadingModal handles creation/update
        showMemoryLoadingModal(message, progressPercent, stage);
        
        // Update file preview progress if filename is provided
        if (filename) {
            const filePreviewContainer = document.getElementById('file-preview-container');
            if (filePreviewContainer) {
                const filePreviews = filePreviewContainer.querySelectorAll('.file-preview.processing');
                filePreviews.forEach(preview => {
                    const fileNameEl = preview.querySelector('.file-preview-name');
                    if (fileNameEl && fileNameEl.textContent === filename) {
                        // Update status message
                        const statusEl = preview.querySelector('.file-preview-status');
                        if (statusEl) {
                            const stageMessages = {
                                'extracting_facts': 'Extracting facts...',
                                'storing_memories': 'Storing memories...',
                                'generating_embeddings': 'Generating embeddings...',
                                'raw_content_stored': 'Storing content...'
                            };
                            const statusMsg = stageMessages[stage] || 'Processing...';
                            statusEl.innerHTML = `<span>‚è≥</span> <span>${statusMsg}</span>`;
                        }
                        
                        // Update progress bar
                        const progressBar = preview.querySelector('.file-preview-progress-bar');
                        if (progressBar && progressPercent !== null) {
                            progressBar.style.width = `${progressPercent}%`;
                        }
                    }
                });
            }
        }
    } else if (data.type === 'memory_stored') {
        // Mark extraction as complete
        memoryExtractionInProgress = false;
        if (memoryExtractionTimeout) {
            clearTimeout(memoryExtractionTimeout);
            memoryExtractionTimeout = null;
        }
        
        const success = !data.errors || data.errors.length === 0;
        const memoryCount = data.memory_count || 0;
        const taskCompleted = data.task_completed === true;
        const filename = data.filename;
        
        console.log('üì¶ memory_stored event:', { taskCompleted, filename, memoryCount, success });
        
        // Update file preview to completed state if filename provided
        if (filename && success) {
            const filePreviewContainer = document.getElementById('file-preview-container');
            if (filePreviewContainer) {
                const filePreviews = filePreviewContainer.querySelectorAll('.file-preview.processing');
                filePreviews.forEach(preview => {
                    const fileNameEl = preview.querySelector('.file-preview-name');
                    if (fileNameEl && fileNameEl.textContent === filename) {
                        preview.classList.remove('processing');
                        preview.classList.add('completed');
                        
                        // Update status
                        const statusEl = preview.querySelector('.file-preview-status');
                        if (statusEl) {
                            statusEl.innerHTML = `<span>‚úÖ</span> <span>${memoryCount} memories extracted</span>`;
                        }
                        
                        // Complete progress bar
                        const progressBar = preview.querySelector('.file-preview-progress-bar');
                        if (progressBar) {
                            progressBar.style.width = '100%';
                            progressBar.style.background = 'linear-gradient(90deg, rgba(16, 185, 129, 1), rgba(59, 130, 246, 1))';
                        }
                    }
                });
            }
        }
        
        // Remove any memory extraction indicators
        const extractionIndicators = document.querySelectorAll('.memory-extraction-indicator');
        extractionIndicators.forEach(el => {
            const msgDiv = el.closest('.message');
            if (msgDiv) msgDiv.remove();
        });
        
        // Handle completion: task_completed=true means ALL processing is done
        if (taskCompleted) {
            // Handle per-file events (filename present = individual file)
            if (filename) {
                const message = data.message || `Mem0 stored ${memoryCount} memories`;
            } else {
                // Final completion event (no filename) - backend signals all processing done
                console.log('‚úÖ Backend signaled completion - closing modal');
                
                // Update modal to show completion
                if (memoryLoadingModal) {
                    showMemoryLoadingModal(
                        success && memoryCount > 0 
                            ? `‚úÖ Complete! Stored ${memoryCount} memories successfully`
                            : success 
                                ? '‚úÖ Complete!'
                                : '‚ö†Ô∏è Completed with errors',
                        success ? 100 : null
                    );
                }
                
                // Show success message in chat (only once)
                if (success && memoryCount > 0) {
                    addMessage('assistant', `
                        <div class="memory-extraction-success">
                            <div class="memory-extraction-success-icon">‚úÖ</div>
                            <div class="memory-extraction-success-text">
                                <div class="memory-extraction-success-title">Memories extracted!</div>
                                <div class="memory-extraction-success-subtitle">${memoryCount} fact${memoryCount !== 1 ? 's' : ''} stored from your document${memoryCount > 1 ? 's' : ''}</div>
                            </div>
                        </div>
                    `);
                }
                
                const message = data.message || `Mem0 stored ${memoryCount} memories`;
                const fullMessage = success 
                    ? message + (data.total_memories ? ` (${data.total_memories} total)` : '')
                    : message + (data.errors ? ` - Errors: ${data.errors.join(', ')}` : '');
                
                // Close modal and refresh - backend has confirmed completion
                setTimeout(() => {
                    hideMemoryLoadingModal();
                    // Mark extraction as complete
                    memoryExtractionInProgress = false;
                    if (memoryExtractionTimeout) {
                        clearTimeout(memoryExtractionTimeout);
                        memoryExtractionTimeout = null;
                    }
                    
                    // Refresh file contexts for Memory Navigator (non-blocking)
                    refreshFileContexts().catch(err => console.error('Failed to refresh file contexts:', err));
                    
                    // Auto-refresh active context memories in real-time (non-blocking)
                    if (success && memoryCount > 0) {
                        setTimeout(() => {
                            // Refresh all memories in active context to show newly stored ones
                            refreshMemories(null, 'general', 0, false).catch(err => 
                                console.error('Failed to auto-refresh memories:', err)
                            );
                        }, 1500); // Small delay to ensure backend has finished storing
                    }
                    
                    // Show toast notification
                    if (success && memoryCount > 0) {
                        const indicator = document.getElementById('memory-storage-indicator');
                        if (indicator) {
                            indicator.textContent = `File analyzed: ${memoryCount} new facts extracted`;
                            indicator.classList.add('show');
                            setTimeout(() => indicator.classList.remove('show'), 4000);
                        }
                    }
                }, 800); // Brief delay to show completion message
            }
        } else {
            // Legacy handling for non-task-completed events
            const message = data.message || `Mem0 stored ${memoryCount} memories`;
            
            if (success && data.memory_count > 0) {
                setTimeout(async () => {
                    await refreshFileContexts();
                    // Auto-refresh active context memories in real-time
                    refreshMemories(null, 'general', 0, false).catch(err => 
                        console.error('Failed to auto-refresh memories:', err)
                    );
                }, 2000);
            }
        }
        
        if (!success) {
            // Show error notification
            console.error('Memory storage errors:', data.errors);
            hideMemoryLoadingModal();
            addMessage('assistant', `<div style="color: #f85149; padding: 12px; background: rgba(248, 81, 73, 0.1); border-radius: 8px; border-left: 3px solid #f85149;"><strong>‚ö†Ô∏è Memory Storage Warning:</strong> ${data.errors ? data.errors.join('<br>') : 'Unknown error'}</div>`);
        }
    }
}

function startPollingFallback() {
    console.log('Starting polling fallback mode');
    // Polling fallback - UI should be enabled for this mode
    // Note: Active Context is updated with retrieved memories, not refreshed here
    setInterval(async () => {
        await refreshFileContexts();
        // Memory Navigator can be refreshed manually if needed
    }, 10000);
}

// File Upload Functions
function validateFile(file) {
    if (!file || !file.name) {
        alert('Invalid file selected.');
        return false;
    }
    
    if (file.size > MAX_FILE_SIZE) {
        alert(`File "${file.name}" is too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB.`);
        return false;
    }
    
    if (file.size === 0) {
        alert(`File "${file.name}" is empty.`);
        return false;
    }
    
    // Simple extension check if MIME type is generic
    const ext = '.' + file.name.split('.').pop().toLowerCase();
    // Allow essentially all common text/doc formats
    return true; 
}

function addFileToPreview(file) {
    if (!validateFile(file)) return;
    
    // Check for duplicate files
    const isDuplicate = selectedFiles.find(f => f.name === file.name && f.size === file.size);
    if (isDuplicate) {
        // Show a subtle notification instead of alert
        const container = document.getElementById('file-preview-container');
        if (container) {
            const notification = document.createElement('div');
            notification.style.cssText = 'padding: 8px; background: rgba(255, 193, 7, 0.2); border: 1px solid rgba(255, 193, 7, 0.4); border-radius: 6px; color: #ffc107; font-size: 12px; margin-bottom: 8px;';
            notification.textContent = `‚ö†Ô∏è "${file.name}" is already selected`;
            container.insertBefore(notification, container.firstChild);
            setTimeout(() => notification.remove(), 3000);
        }
        return;
    }
    
    selectedFiles.push(file);
    console.log(`üìé File added: ${file.name} (${file.size} bytes, type: ${file.type || 'unknown'})`);
    console.log(`   Total files selected: ${selectedFiles.length}`);
    updateFilePreview();
    
    // Update upload button visual state
    const uploadBtn = document.getElementById('file-upload-btn');
    if (uploadBtn) {
        uploadBtn.classList.add('has-files');
        uploadBtn.title = `${selectedFiles.length} file(s) selected - Click to add more`;
    }
    
    // Enable send button if files are selected
    const sendBtn = document.getElementById('send-btn');
    if (sendBtn) {
        sendBtn.classList.add('active');
        sendBtn.disabled = false;
    }
}

function removeFileFromPreview(fileName) {
    const beforeCount = selectedFiles.length;
    selectedFiles = selectedFiles.filter(f => f.name !== fileName);
    const removed = beforeCount - selectedFiles.length;
    
    if (removed > 0) {
        console.log(`üóëÔ∏è Removed file: ${fileName} (${selectedFiles.length} file(s) remaining)`);
    }
    
    updateFilePreview();
    
    // Update upload button visual state
    const uploadBtn = document.getElementById('file-upload-btn');
    if (uploadBtn) {
        uploadBtn.classList.toggle('has-files', selectedFiles.length > 0);
        uploadBtn.title = selectedFiles.length > 0 
            ? `${selectedFiles.length} file(s) selected - Click to add more`
            : 'Upload file (or drag & drop)';
    }
    
    // Update send button state
    const sendBtn = document.getElementById('send-btn');
    const messageInput = document.getElementById('message-input');
    if (sendBtn) {
        const hasFiles = selectedFiles.length > 0;
        const hasText = messageInput && messageInput.value.trim().length > 0;
        sendBtn.classList.toggle('active', hasFiles || hasText);
        sendBtn.disabled = !hasFiles && !hasText;
    }
}

function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const iconMap = {
        'pdf': 'üìÑ', 'doc': 'üìù', 'docx': 'üìù',
        'xls': 'üìä', 'xlsx': 'üìä', 'csv': 'üìä',
        'ppt': 'üìä', 'pptx': 'üìä',
        'txt': 'üìÑ', 'md': 'üìù', 'markdown': 'üìù',
        'py': 'üêç', 'js': 'üìú', 'ts': 'üìú', 'html': 'üåê', 'css': 'üé®',
        'json': 'üìã', 'xml': 'üìã', 'yaml': 'üìã', 'yml': 'üìã',
        'jpg': 'üñºÔ∏è', 'jpeg': 'üñºÔ∏è', 'png': 'üñºÔ∏è', 'gif': 'üñºÔ∏è', 'svg': 'üñºÔ∏è',
    };
    return iconMap[ext] || 'üìé';
}

function formatFileSize(bytes) {
    if (bytes < 1024) return `${bytes}B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
}

function updateFilePreview() {
    const container = document.getElementById('file-preview-container');
    const sendBtn = document.getElementById('send-btn');
    const messageInput = document.getElementById('message-input');
    
    if (!container) return;
    
    if (selectedFiles.length === 0) {
        container.innerHTML = '';
        if (sendBtn) {
            const hasText = messageInput && messageInput.value.trim().length > 0;
            sendBtn.classList.toggle('active', hasText);
            sendBtn.disabled = !hasText;
        }
        return;
    }
    
    // Show file count status
    const statusHtml = selectedFiles.length > 0 
        ? `<div class="file-upload-status">üìé ${selectedFiles.length} file${selectedFiles.length > 1 ? 's' : ''} ready to upload</div>`
        : '';
    
    const filesHtml = selectedFiles.map(file => {
        const fileSize = formatFileSize(file.size);
        const fileIcon = getFileIcon(file.name);
        const safeName = file.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        return `
        <div class="file-preview">
            <span class="file-preview-icon">${fileIcon}</span>
            <div class="file-preview-info">
                <span class="file-preview-name" title="${safeName}">${file.name}</span>
                <span class="file-preview-size">${fileSize}</span>
            </div>
            <button type="button" class="file-preview-remove" onclick="removeFileFromPreview('${safeName}')" title="Remove file">‚úï</button>
        </div>
    `;
    }).join('');
    
    container.innerHTML = statusHtml + filesHtml;
    
    // Update input placeholder when files are selected
    if (messageInput) {
        if (selectedFiles.length > 0) {
            messageInput.placeholder = `Type a message (${selectedFiles.length} file${selectedFiles.length > 1 ? 's' : ''} attached)...`;
            messageInput.classList.add('has-files');
        } else {
            messageInput.placeholder = 'Message Orby...';
            messageInput.classList.remove('has-files');
        }
    }
    
    // Enable send button if files are selected
    if (sendBtn) {
        sendBtn.classList.add('active');
        sendBtn.disabled = false;
    }
}

function handleFiles(files) {
    // Critical: Check WebSocket connection before allowing file operations
    if (!isWebSocketConnected && !isConnecting) {
        if (!isConnecting) {
            connectMemoryWebSocket();
        }
        alert('Please wait for the connection to be established before uploading files.');
        return;
    }
    
    if (isConnecting) {
        alert('Connection in progress. Please wait...');
        return;
    }
    
    if (!files || files.length === 0) {
        console.warn('‚ö†Ô∏è No files provided to handleFiles');
        return;
    }
    
    const fileArray = Array.from(files);
    console.log(`üìÇ Handling ${fileArray.length} file(s) from input/drop`);
    
    fileArray.forEach((file, index) => {
        console.log(`   üìÑ File ${index + 1}: ${file.name} (${file.size} bytes, type: ${file.type || 'unknown'})`);
        addFileToPreview(file);
    });
    
    console.log(`‚úÖ All ${fileArray.length} file(s) processed. Total selected: ${selectedFiles.length}`);
}

// Drag and Drop Handlers
function setupDragAndDrop() {
    const chatConsole = document.getElementById('chat-console');
    const inputArea = document.getElementById('conversation-input-area');
    const dragOverlay = document.getElementById('drag-drop-overlay');
    
    if (!chatConsole || !inputArea || !dragOverlay) return;
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        chatConsole.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
        // Critical: Block drag-and-drop if WebSocket not connected
        if (!isWebSocketConnected || isConnecting) {
            e.preventDefault();
            e.stopPropagation();
            if (isConnecting) {
                alert('Please wait for the connection to be established before uploading files.');
            } else {
                alert('Connection not available. Please refresh the page.');
            }
            return;
        }
        e.preventDefault();
        e.stopPropagation();
    }
    
    ['dragenter', 'dragover'].forEach(eventName => {
        chatConsole.addEventListener(eventName, (e) => {
            // Only show drag overlay if connected
            if (!isWebSocketConnected || isConnecting) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            inputArea.classList.add('drag-over');
            dragOverlay.classList.add('active');
        }, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        chatConsole.addEventListener(eventName, () => {
            inputArea.classList.remove('drag-over');
            dragOverlay.classList.remove('active');
        }, false);
    });
    
    chatConsole.addEventListener('drop', (e) => {
        // Critical: Block drop if WebSocket not connected
        if (!isWebSocketConnected || isConnecting) {
            e.preventDefault();
            e.stopPropagation();
            if (isConnecting) {
                alert('Please wait for the connection to be established before uploading files.');
            } else {
                alert('Connection not available. Please refresh the page.');
            }
            return;
        }
        const dt = e.dataTransfer;
        const files = dt.files;
        handleFiles(files);
    }, false);
}

// Scroll to bottom on load
window.addEventListener('load', async () => {
    // CRITICAL: Disable UI immediately and connect WebSocket first
    setConnectionState(false, true);
    
    populateCategorySelect(); // Populate category selector in input area
    scrollToBottom();
    
    // Setup drag and drop first (it will check connection state)
    setupDragAndDrop();
    
    // Load initial data (but UI remains disabled until WebSocket connects)
    // Don't await - let it load in background
    // Note: Active Context starts empty - it will be populated when AI retrieves memories
    // Memory Navigator can be refreshed separately if needed
    refreshFileContexts().catch(err => console.error('Failed to refresh file contexts:', err));
    
    // Connect WebSocket - this will enable UI when connected
    // Use a small delay to ensure DOM is fully ready
    setTimeout(() => {
        connectMemoryWebSocket();
        
        // Safety fallback: If WebSocket doesn't connect within 15 seconds, enable UI anyway
        // This prevents the UI from being permanently blocked if WebSocket is unavailable
        setTimeout(() => {
            if (!isWebSocketConnected && isConnecting) {
                console.warn('WebSocket connection timeout - enabling UI with fallback mode');
                isConnecting = false;
                startPollingFallback();
                setConnectionState(true, false);
                
                const overlay = document.getElementById('websocket-connecting-overlay');
                if (overlay) {
                    overlay.classList.add('hidden');
                }
            }
        }, 15000); // 15 second safety timeout
    }, 100);
    
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
            fileInput.value = ''; 
        });
    }
    
    document.getElementById('category-modal')?.addEventListener('click', (e) => {
        if (e.target.id === 'category-modal') {
            hideAddCategoryModal();
        }
    });

    const orb = document.getElementById('orb');
    if (orb) {
        orb.addEventListener('click', () => {
            const colors = ['rgba(138, 43, 226, 0.7)', 'rgba(29, 38, 113, 0.7)', 'rgba(0, 123, 255, 0.7)', 'rgba(0, 255, 255, 0.7)', 'rgba(255, 105, 180, 0.7)', 'rgba(255, 165, 0, 0.7)', 'rgba(50, 205, 50, 0.7)', 'rgba(220, 20, 60, 0.7)'];
            orb.style.setProperty('--aura-color', colors[Math.floor(Math.random() * colors.length)]);
        });
    }

    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    if (messageInput && sendBtn) {
        const updateSendButton = () => {
            const hasText = messageInput.value.trim().length > 0;
            const hasFiles = selectedFiles.length > 0;
            sendBtn.classList.toggle('active', hasText || hasFiles);
            sendBtn.disabled = !hasText && !hasFiles;
        };
        
        messageInput.addEventListener('input', updateSendButton);
        messageInput.addEventListener('focus', () => {
            if (orb) orb.classList.add('listening');
        });
        messageInput.addEventListener('blur', () => {
            if (orb) orb.classList.remove('listening');
        });
        
        const fileObserver = new MutationObserver(updateSendButton);
        const fileContainer = document.getElementById('file-preview-container');
        if (fileContainer) {
            fileObserver.observe(fileContainer, { childList: true, subtree: true });
        }
    }
});

// Global state for memory loading modal
let memoryLoadingModal = null;
let memoryLoadingProgress = null;
let memoryExtractionInProgress = false;
let lastMemoryProgressTime = null;
let memoryExtractionTimeout = null;
let memoryExtractionSteps = [];
let memoryRefreshAborted = false;
let modalAutoCloseTimeout = null; // Safety timeout to close stuck modals

function showMemoryLoadingModal(message = 'Loading memories...', progress = null, stage = null) {
    // Create or update modal
    if (!memoryLoadingModal) {
        memoryLoadingModal = document.createElement('div');
        memoryLoadingModal.id = 'memory-loading-modal';
        memoryLoadingModal.className = 'memory-loading-modal';
        memoryLoadingModal.innerHTML = `
            <div class="memory-loading-modal-content">
                <div class="memory-loading-modal-header">
                    <div class="memory-loading-spinner-large"></div>
                    <h3>Processing Memories</h3>
                </div>
                <div class="memory-loading-modal-body">
                    <p class="memory-loading-message">${escapeHtml(message)}</p>
                    <div class="memory-loading-steps" id="memory-loading-steps"></div>
                    ${progress !== null ? `<div class="memory-loading-progress"><div class="memory-loading-progress-bar" style="width: ${progress}%"></div></div>` : ''}
                    <div class="memory-loading-actions">
                        <button class="memory-loading-abort-btn" id="memory-loading-abort-btn" onclick="abortMemoryRefresh()" style="display: none;">
                            <span>‚èπ</span> Abort & Continue
                        </button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(memoryLoadingModal);
        // Block UI interactions
        document.body.style.pointerEvents = 'none';
        memoryLoadingModal.style.pointerEvents = 'auto';
    } else {
        const messageEl = memoryLoadingModal.querySelector('.memory-loading-message');
        const stepsContainer = memoryLoadingModal.querySelector('#memory-loading-steps');
        const progressContainer = memoryLoadingModal.querySelector('.memory-loading-progress');
        const abortBtn = memoryLoadingModal.querySelector('#memory-loading-abort-btn');
        
        if (messageEl) {
            messageEl.textContent = message;
            console.log('‚úÖ Updated modal message:', message.substring(0, 50));
        }
        
        // Update steps if stage provided
        if (stage && stepsContainer) {
            console.log('üìù Adding step:', stage, message.substring(0, 50));
            addMemoryExtractionStep(stage, message);
        } else if (stage) {
            console.warn('‚ö†Ô∏è Stage provided but no steps container:', stage);
        }
        
        if (progress !== null) {
            if (!progressContainer) {
                const body = memoryLoadingModal.querySelector('.memory-loading-modal-body');
                if (body) {
                    const progressDiv = document.createElement('div');
                    progressDiv.className = 'memory-loading-progress';
                    progressDiv.innerHTML = `<div class="memory-loading-progress-bar" style="width: ${progress}%"></div>`;
                    body.insertBefore(progressDiv, body.querySelector('.memory-loading-actions'));
                }
            } else {
                const bar = progressContainer.querySelector('.memory-loading-progress-bar');
                if (bar) bar.style.width = `${progress}%`;
            }
        }
        
        // Show abort button if extraction is taking too long
        if (abortBtn && memoryExtractionInProgress) {
            const timeSinceLastProgress = lastMemoryProgressTime ? Date.now() - lastMemoryProgressTime : 0;
            if (timeSinceLastProgress > MEMORY_EXTRACTION_TIMEOUT) {
                abortBtn.style.display = 'inline-flex';
            }
        }
    }
    memoryLoadingModal.classList.add('show');
    
    // Note: Modal will close when backend sends task_completed=true event
    // No auto-close timeout - we wait for backend signal
}

function addMemoryExtractionStep(stage, message) {
    if (!memoryLoadingModal) return;
    
    const stepsContainer = memoryLoadingModal.querySelector('#memory-loading-steps');
    if (!stepsContainer) return;
    
    // Check if this is a duplicate of the last step (for storing_memories with fact numbers)
    const lastStep = memoryExtractionSteps[memoryExtractionSteps.length - 1];
    if (lastStep && lastStep.stage === stage && stage === 'storing_memories') {
        // Update the last step instead of adding a new one for storing_memories
        lastStep.message = message;
        lastStep.timestamp = Date.now();
    } else {
        // Add new step to history
        memoryExtractionSteps.push({
            stage: stage,
            message: message,
            timestamp: Date.now()
        });
    }
    
    // Keep only last 15 steps (increased for more detail)
    if (memoryExtractionSteps.length > 15) {
        memoryExtractionSteps.shift();
    }
    
    // Render steps
    const stepsHtml = memoryExtractionSteps.map((step, idx) => {
        const isLast = idx === memoryExtractionSteps.length - 1;
        const stageIcons = {
            'starting': 'üöÄ',
            'extracting_facts': 'üß†',
            'storing_chat': 'üí¨',
            'storing_memories': 'üíæ',
            'generating_embeddings': 'üîç',
            'raw_content_stored': '‚úÖ',
            'error': '‚ùå'
        };
        const icon = stageIcons[step.stage] || '‚è≥';
        return `
            <div class="memory-loading-step ${isLast ? 'active' : ''}">
                <span class="memory-loading-step-icon">${icon}</span>
                <span class="memory-loading-step-text">${escapeHtml(step.message)}</span>
            </div>
        `;
    }).join('');
    
    stepsContainer.innerHTML = stepsHtml;
    
    // Scroll to bottom
    stepsContainer.scrollTop = stepsContainer.scrollHeight;
}

function abortMemoryRefresh() {
    memoryRefreshAborted = true;
    memoryExtractionInProgress = false;
    isWaitingForNewMemories = false;
    if (memoryExtractionTimeout) {
        clearTimeout(memoryExtractionTimeout);
        memoryExtractionTimeout = null;
    }
    hideMemoryLoadingModal();
    console.log('[Memory Refresh] User aborted memory refresh');
}

function hideMemoryLoadingModal() {
    // Clear any auto-close timeout
    if (modalAutoCloseTimeout) {
        clearTimeout(modalAutoCloseTimeout);
        modalAutoCloseTimeout = null;
    }
    
    if (memoryLoadingModal) {
        memoryLoadingModal.classList.remove('show');
        setTimeout(() => {
            if (memoryLoadingModal && memoryLoadingModal.parentNode) {
                memoryLoadingModal.parentNode.removeChild(memoryLoadingModal);
            }
            memoryLoadingModal = null;
            document.body.style.pointerEvents = '';
            // Reset steps when modal is hidden
            memoryExtractionSteps = [];
        }, 300);
    }
}

// Update Active Context with retrieved memories (only memories used by AI)
function updateActiveContext(retrievedMemories) {
    const container = document.getElementById('memory-context-list');
    if (!container) return;
    
    if (!retrievedMemories || retrievedMemories.length === 0) {
        container.innerHTML = '<div class="empty-memory-state">No memories retrieved for this query. The AI is responding without memory context.</div>';
        updateMemoryCount(0, 0);
        return;
    }
    
    // Display retrieved memories
    const displayResult = displayMemories(retrievedMemories);
    updateMemoryCount(displayResult.displayedCount, retrievedMemories.length);
}

// Refresh Memory Navigator - Shows all memories for exploration
// NOTE: This is separate from Active Context which only shows retrieved memories
async function refreshMemories(sourceFilter = null, categoryFilter = 'general', retryAttempt = 0, isRetry = false) {
    const container = document.getElementById('memory-context-list');
    if (!container) return;
    
    // Only show blocking modal if memory extraction is actually in progress
    // Never show modal for regular refreshes - only when extraction is happening
    const shouldShowModal = memoryExtractionInProgress;
    
    if (shouldShowModal && !isRetry) {
        // Only show modal if extraction is happening
        if (!memoryLoadingModal) {
            showMemoryLoadingModal('Loading memories from database...', null);
        }
    } else if (!shouldShowModal && !isRetry && retryAttempt === 0) {
        // Show subtle loading state in container instead of blocking modal (only on first attempt)
        // Don't overwrite if container already has content
        if (!container.innerHTML || container.innerHTML.trim() === '' || container.querySelector('.empty-memory-state')) {
            container.innerHTML = `
                <div class="memory-loading-state">
                    <div class="memory-loading-spinner"></div>
                    <div class="memory-loading-text">Loading memories...</div>
                </div>
            `;
        }
    }
    
    try {
        console.log(`[Memory Refresh] Attempt ${retryAttempt + 1}${isRetry ? ' (retry)' : ''}`);
        
        // Only update modal if it's already showing (extraction in progress)
        if (memoryLoadingModal && shouldShowModal) {
            showMemoryLoadingModal('Fetching memories from database...', null);
        }
        
        // Get all memories - no filtering in right panel (filters moved to Memory Navigator)
        // Increased limit to show more memories in active context
        const response = await fetch('/api/memories?limit=500');
        if (!response.ok) {
            throw new Error(`Failed to fetch memories: ${response.status}`);
        }
        
        // Only update modal if it's already showing (extraction in progress)
        if (memoryLoadingModal && shouldShowModal) {
            showMemoryLoadingModal('Processing memory data...', null);
        }
        
        const data = await response.json();
        if (!data.success) {
            throw new Error('Failed to get memories');
        }
        
        // Only update modal if it's already showing (extraction in progress)
        if (memoryLoadingModal && shouldShowModal) {
            showMemoryLoadingModal('Validating and formatting memories...', 50);
        }
        
        // Validate memories array format
        let memories = data.memories || [];
        if (!Array.isArray(memories)) {
            console.error('[Memory Refresh] Invalid memories format:', memories);
            memories = [];
        }
        
        // Ensure each memory has proper structure
        memories = memories.filter(m => {
            if (!m || typeof m !== 'object') {
                console.warn('[Memory Refresh] Invalid memory object:', m);
                return false;
            }
            // Ensure memory has required fields
            if (!m.memory && !m.id) {
                console.warn('[Memory Refresh] Memory missing required fields:', m);
                return false;
            }
            return true;
        });

        // Only update modal if it's already showing (extraction in progress)
        if (memoryLoadingModal && shouldShowModal) {
            showMemoryLoadingModal('Rendering memory cards...', 75);
        }

        if (memories.length > 0) {
            console.log(`[Memory Refresh] Successfully loaded ${memories.length} memories`);
            
            // Only update modal if it's already showing (extraction in progress)
            if (memoryLoadingModal && shouldShowModal) {
                showMemoryLoadingModal(`Displaying ${memories.length} memories...`, 90);
            }
            
            // Use requestAnimationFrame for smooth transition
            requestAnimationFrame(() => {
                const displayResult = displayMemories(memories);
                // Update count with both displayed and total counts
                updateMemoryCount(displayResult.displayedCount, memories.length);
                // Hide modal after a brief delay ONLY if it was showing (extraction in progress)
                if (memoryLoadingModal && shouldShowModal) {
                    setTimeout(() => {
                        if (memoryLoadingModal) {
                            showMemoryLoadingModal('Complete!', 100);
                            setTimeout(hideMemoryLoadingModal, 500);
                        }
                    }, 100);
                }
            });
            // Reset retry state on success
            memoryRefreshRetryCount = 0;
            isWaitingForNewMemories = false;
        } else {
            // No memories found - retry if waiting for new memories AND extraction is still in progress OR not aborted
            if (isWaitingForNewMemories && !memoryRefreshAborted && retryAttempt < MAX_MEMORY_RETRY_ATTEMPTS) {
                // Don't retry if extraction is in progress - wait for WebSocket completion
                if (memoryExtractionInProgress) {
                    console.log(`[Memory Refresh] Extraction in progress, waiting for completion... (attempt ${retryAttempt + 1})`);
                    // Only show/update modal if extraction is in progress
                    if (!memoryLoadingModal) {
                        showMemoryLoadingModal('Memory extraction in progress, waiting for completion...', null);
                    } else {
                        showMemoryLoadingModal('Memory extraction in progress, waiting for completion...', null);
                    }
                    // Retry after longer delay when extraction is in progress
                    setTimeout(() => {
                        if (!memoryRefreshAborted) {
                            refreshMemories(sourceFilter, categoryFilter, retryAttempt, true);
                        }
                    }, 15000); // Wait 15s if extraction is in progress
                } else {
                    const delay = MEMORY_RETRY_DELAYS[retryAttempt] || MEMORY_RETRY_DELAYS[MEMORY_RETRY_DELAYS.length - 1];
                    console.log(`[Memory Refresh] No memories found, retrying in ${delay}ms (attempt ${retryAttempt + 1}/${MAX_MEMORY_RETRY_ATTEMPTS})`);
                    // Only show/update modal if extraction is in progress
                    if (memoryExtractionInProgress) {
                        if (memoryLoadingModal) {
                            showMemoryLoadingModal(`Waiting for memories to be stored... (attempt ${retryAttempt + 1}/${MAX_MEMORY_RETRY_ATTEMPTS})`, null);
                        }
                    } else if (container) {
                        container.innerHTML = `
                            <div class="memory-loading-state">
                                <div class="memory-loading-spinner"></div>
                                <div class="memory-loading-text">Waiting for memories... (attempt ${retryAttempt + 1}/${MAX_MEMORY_RETRY_ATTEMPTS})</div>
                            </div>
                        `;
                    }
                    setTimeout(() => {
                        if (!memoryRefreshAborted) {
                            refreshMemories(sourceFilter, categoryFilter, retryAttempt + 1, true);
                        }
                    }, delay);
                }
            } else {
                // Hide modal and show empty state (only if aborted or max attempts reached)
                if (memoryRefreshAborted || retryAttempt >= MAX_MEMORY_RETRY_ATTEMPTS) {
                    hideMemoryLoadingModal();
                    requestAnimationFrame(() => {
                        if (container) {
                            if (memoryRefreshAborted) {
                                container.innerHTML = '<div class="empty-memory-state">Memory refresh aborted. Memories may still be processing in the background.</div>';
                            } else {
                                container.innerHTML = '<div class="empty-memory-state">No memories in this category yet. Start chatting to build context!</div>';
                            }
                        }
                    });
                    // Reset retry state
                    if (retryAttempt >= MAX_MEMORY_RETRY_ATTEMPTS) {
                        console.log('[Memory Refresh] Max retry attempts reached, giving up');
                    }
                    isWaitingForNewMemories = false;
                    memoryRefreshRetryCount = 0;
                }
            }
        }
        
        // Refresh file contexts for bucket headers
        await refreshFileContexts();
    } catch (error) {
        console.error('[Memory Refresh] Failed to refresh memories:', error);
        // Only hide modal if it was showing (extraction in progress)
        if (memoryLoadingModal && memoryExtractionInProgress) {
            hideMemoryLoadingModal();
        }
        requestAnimationFrame(() => {
            if (container) {
                container.innerHTML = '<div class="empty-memory-state">Error loading memories. Please refresh the page.</div>';
            }
        });
        // Reset retry state on error
        isWaitingForNewMemories = false;
        memoryRefreshRetryCount = 0;
        memoryExtractionInProgress = false;
    }
}

function updateMemoryCount(displayedCount, totalCount = null) {
    const title = document.querySelector('.memory-panel-title');
    if (title) {
        let existingBadge = title.querySelector('.memory-count-badge');
        if (!existingBadge) {
            existingBadge = document.createElement('span');
            existingBadge.className = 'memory-count-badge';
            title.appendChild(existingBadge);
        }
        
        if (totalCount !== null && totalCount !== displayedCount) {
            existingBadge.textContent = `${displayedCount} of ${totalCount} memories`;
            existingBadge.title = `${totalCount - displayedCount} memories filtered out (raw content or invalid)`;
            existingBadge.classList.add('has-filtered');
        } else {
            existingBadge.textContent = `${displayedCount} memory${displayedCount !== 1 ? 'ies' : ''}`;
            existingBadge.title = '';
            existingBadge.classList.remove('has-filtered');
        }
    }
}

// Load available file contexts and buckets into the dropdowns
async function refreshFileContexts() {
    try {
        const response = await fetch('/api/memories/stats');
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.stats) {
                // Store bucket_files globally for use in displayMemories
                bucketFilesData = data.stats.bucket_files || {};
                
                // Update file contexts dropdown
                const fileSelect = document.getElementById('file-context-filter');
                if (fileSelect && data.stats.file_contexts) {
                    const fileContexts = data.stats.file_contexts;
                    const currentValue = fileSelect.value;
                    
                    fileSelect.innerHTML = '<option value="">All Files</option>';
                    
                    for (const [filename, info] of Object.entries(fileContexts)) {
                        const option = document.createElement('option');
                        option.value = info.context_id;
                        option.textContent = `${filename} (${info.count} memories)`;
                        fileSelect.appendChild(option);
                    }
                    
                    if (currentValue) {
                        fileSelect.value = currentValue;
                    }
                }
                
                // Update bucket filter dropdown with general buckets
                const bucketSelect = document.getElementById('bucket-filter');
                if (bucketSelect && data.stats.general_buckets) {
                    const generalBuckets = data.stats.general_buckets;
                    const currentBucketValue = bucketSelect.value;
                    
                    // Keep existing options but add general bucket options
                    const allFilesOption = bucketSelect.querySelector('option[value="file"]');
                    const generalOption = bucketSelect.querySelector('option[value="general"]');
                    
                    // Add specific general bucket options
                    for (const [bucketId, info] of Object.entries(generalBuckets)) {
                        const existingOption = Array.from(bucketSelect.options).find(opt => opt.value === bucketId);
                        if (!existingOption) {
                            const option = document.createElement('option');
                            option.value = bucketId;
                            option.textContent = `üìÅ ${info.name} (${info.count} memories)`;
                            option.dataset.bucketType = 'general';
                            // Insert after "General Buckets" option
                            if (generalOption && generalOption.nextSibling) {
                                bucketSelect.insertBefore(option, generalOption.nextSibling);
                            } else {
                                bucketSelect.appendChild(option);
                            }
                        }
                    }
                    
                    if (currentBucketValue) {
                        bucketSelect.value = currentBucketValue;
                    }
                }
            }
        }
    } catch (error) {
        console.error('Failed to refresh file contexts:', error);
    }
}

function displayMemories(memories) {
    const container = document.getElementById('memory-context-list');
    if (!container) return { displayedCount: 0, totalCount: memories.length };
    
    const totalCount = memories.length;

    // Validate input - ensure it's an array
    if (!Array.isArray(memories)) {
        console.error('[displayMemories] Invalid input - expected array, got:', typeof memories, memories);
        container.innerHTML = '<div class="empty-memory-state">Error: Invalid memory data format</div>';
        return { displayedCount: 0, totalCount: 0 };
    }

    const searchInput = document.getElementById('memory-search-input');
    const isSearching = searchInput && searchInput.value.trim().length > 0;

    if (!memories || memories.length === 0) {
        const emptyClass = isSearching ? 'search-empty' : '';
        container.innerHTML = `<div class="empty-memory-state ${emptyClass}">${isSearching ? 'No memories found. Try different search terms or clear filters.' : 'No memories in this category yet. Start chatting to build context!'}</div>`;
        return { displayedCount: 0, totalCount: totalCount };
    }
    
    // Validate each memory object
    const validMemories = memories.filter(m => {
        if (!m || typeof m !== 'object') {
            console.warn('[displayMemories] Skipping invalid memory:', m);
            return false;
        }
        // Ensure memory has at least an id or memory field
        if (!m.id && !m.memory) {
            console.warn('[displayMemories] Skipping memory without id or memory field:', m);
            return false;
        }
        return true;
    });
    
    if (validMemories.length === 0) {
        container.innerHTML = '<div class="empty-memory-state">No valid memories to display</div>';
        return { displayedCount: 0, totalCount: totalCount };
    }

    // Filter out raw_content memories from active context (show only fact extractions)
    // Active context focuses on key insights, not raw content
    const filteredMemories = validMemories.filter(m => {
        // Ensure metadata exists
        if (!m.metadata || typeof m.metadata !== 'object') {
            m.metadata = {};
        }
        const memoryType = m.metadata?.memory_type;
        // Always exclude raw_content from active context
        return !memoryType || memoryType !== 'raw_content';
    });
    
    if (!filteredMemories || filteredMemories.length === 0) {
        const emptyClass = isSearching ? 'search-empty' : '';
        container.innerHTML = `<div class="empty-memory-state ${emptyClass}">${isSearching ? 'No memories found. Try different search terms or clear filters.' : 'No memories in this category yet. Start chatting to build context!'}</div>`;
        return { displayedCount: 0, totalCount: totalCount, filteredCount: validMemories.length };
    }

    // Group memories by bucket_id or context_id
    const bucketGroups = {};
    const ungrouped = [];
    
    filteredMemories.forEach((memory, index) => {
        const metadata = memory.metadata || {};
        const bucketId = metadata.bucket_id || metadata.context_id;
        const bucketType = metadata.bucket_type || metadata.context_type;
        const filename = metadata.filename;
        
        if (bucketId) {
            if (!bucketGroups[bucketId]) {
                if (bucketType === 'file' && filename) {
                    bucketGroups[bucketId] = {
                        bucketId: bucketId,
                        name: filename,
                        type: 'file',
                        icon: 'üìÑ',
                        memories: []
                    };
                } else if (bucketType === 'general') {
                    bucketGroups[bucketId] = {
                        bucketId: bucketId,
                        name: metadata.category || 'General',
                        type: 'general',
                        icon: 'üìÅ',
                        memories: []
                    };
                } else {
                    // Fallback for legacy file contexts
                    bucketGroups[bucketId] = {
                        bucketId: bucketId,
                        name: filename || 'File',
                        type: 'file',
                        icon: 'üìÑ',
                        memories: []
                    };
                }
            }
            bucketGroups[bucketId].memories.push(memory);
        } else {
            ungrouped.push(memory);
        }
    });
    
    // Build HTML
    let html = '';
    
    // Sort buckets: general buckets first, then file buckets
    const sortedBuckets = Object.entries(bucketGroups).sort((a, b) => {
        if (a[1].type === 'general' && b[1].type !== 'general') return -1;
        if (a[1].type !== 'general' && b[1].type === 'general') return 1;
        return a[1].name.localeCompare(b[1].name);
    });
    
    // Show bucket groups
    for (const [bucketId, group] of sortedBuckets) {
        // Get file count for this bucket
        const bucketFiles = bucketFilesData[bucketId] || [];
        const fileCount = bucketFiles.length;
        const safeBucketId = escapeJsString(bucketId);
        const safeBucketName = escapeJsString(group.name);
        
        html += `<div class="memory-bucket" data-bucket-type="${group.type}">`;
        html += `<div class="memory-bucket-header">`;
        html += `<div class="memory-bucket-title">${group.icon} ${escapeHtml(group.name)}</div>`;
        html += `<div class="memory-bucket-actions">`;
        if (fileCount > 0) {
            html += `<span class="bucket-file-count">${fileCount} file${fileCount > 1 ? 's' : ''}</span>`;
        }
        html += `<button class="bucket-file-explorer-btn" onclick="event.stopPropagation(); showFileExplorer('${safeBucketId}', '${safeBucketName}')" title="Manage files in this bucket">`;
        html += `<span>üìÅ</span> Files`;
        html += `</button>`;
        html += `</div>`;
        html += `<div class="memory-bucket-count">${group.memories.length} memory${group.memories.length > 1 ? 'ies' : ''}</div>`;
        html += `</div>`;
        
        group.memories.forEach((memory, index) => {
            // Ensure memory has proper structure
            if (!memory || typeof memory !== 'object') {
                console.warn('[displayMemories] Skipping invalid memory in group:', memory);
                return;
            }
            
            // Extract memory text - handle both string and object formats
            let memoryText = '';
            
            // First, try memory.memory if it's a string (most common case)
            if (typeof memory.memory === 'string' && memory.memory.trim().length > 0) {
                // Check if it's a stringified object (starts with { or [)
                const trimmed = memory.memory.trim();
                if (trimmed.startsWith('{') || trimmed.startsWith('[') || trimmed.startsWith("'{")) {
                    // Try to parse it as JSON and extract the actual memory text
                    try {
                        // Handle Python dict-style strings (single quotes) by converting to double quotes
                        let jsonString = memory.memory.trim();
                        if (jsonString.startsWith("'") || jsonString.startsWith('"')) {
                            // Try to fix Python dict format
                            jsonString = jsonString.replace(/'/g, '"');
                        }
                        const parsed = JSON.parse(jsonString);
                        if (typeof parsed === 'string') {
                            memoryText = parsed;
                        } else if (parsed && typeof parsed === 'object') {
                            memoryText = parsed.memory || parsed.text || parsed.content || '';
                        }
                    } catch (e) {
                        // Not valid JSON, might be Python dict string - try to extract memory field manually
                        // Look for pattern like 'memory': 'actual text here'
                        const memoryMatch = memory.memory.match(/'memory':\s*['"]([^'"]+)['"]/);
                        if (memoryMatch && memoryMatch[1]) {
                            memoryText = memoryMatch[1];
                        } else {
                            // Skip stringified objects entirely
                            console.warn('[displayMemories] memory.memory appears to be stringified object, skipping:', memory.memory.substring(0, 100));
                        }
                    }
                } else {
                    // It's a regular string, use it
                    memoryText = memory.memory;
                }
            }
            
            // If still empty, try memory.text
            if (!memoryText && memory.text && typeof memory.text === 'string' && memory.text.trim().length > 0) {
                memoryText = memory.text;
            }
            
            // If memory.memory is an object, extract text from it
            if (!memoryText && typeof memory.memory === 'object' && memory.memory !== null) {
                memoryText = memory.memory.memory || memory.memory.text || memory.memory.content || '';
            }
            
            // Fallback: try other common text fields
            if (!memoryText) {
                const textFields = ['content', 'message', 'fact', 'insight'];
                for (const field of textFields) {
                    if (memory[field] && typeof memory[field] === 'string' && memory[field].trim().length > 0) {
                        memoryText = memory[field];
                        break;
                    }
                }
            }
            
            // Last resort: find any string property that looks like content (not metadata)
            if (!memoryText && typeof memory === 'object') {
                const skipKeys = ['id', 'hash', 'created_at', 'updated_at', 'user_id', 'role', 'metadata', 'bucket_id', 'context_id'];
                for (const [key, value] of Object.entries(memory)) {
                    if (skipKeys.includes(key)) continue;
                    if (typeof value === 'string' && value.trim().length > 0) {
                        // Skip if it looks like a stringified object or JSON
                        const trimmed = value.trim();
                        if (!trimmed.startsWith('{') && !trimmed.startsWith('[') && trimmed.length < 500) {
                            memoryText = value;
                            break;
                        }
                    }
                }
            }
            
            // Final fallback
            if (!memoryText || memoryText.trim().length === 0) {
                memoryText = 'Memory content unavailable';
            }
            
            // Clean up the text - remove any remaining object-like patterns
            memoryText = memoryText.trim();
            
            memoryText = escapeHtml(memoryText);
            const memoryId = String(memory.id || `mem-${index}`);
            const metadata = (memory.metadata && typeof memory.metadata === 'object') ? memory.metadata : {};
            
            // Truncate long memory text for compact display
            const maxLength = 120;
            const displayText = memoryText.length > maxLength 
                ? memoryText.substring(0, maxLength) + '...' 
                : memoryText;
            
            // Only show essential metadata tags (category, source) - hide others
            const essentialTags = Object.entries(metadata)
                .filter(([k]) => ['category', 'source'].includes(k))
                .map(([k, v]) => {
                    const extraClass = k === 'category' ? 'category' : k === 'source' ? 'source' : '';
                    return `<span class="metadata-tag ${extraClass}">${escapeHtml(String(v))}</span>`;
                }).join('');
            
            html += `
                <div class="memory-item" onclick="showMemoryDetails('${memoryId}')" title="${escapeHtml(memoryText)}">
                    <div class="memory-item-header">
                        <span class="memory-icon">${group.type === 'file' ? 'üìÑ' : 'üí≠'}</span>
                        <div class="memory-text">${displayText}</div>
                    </div>
                    ${essentialTags ? `<div class="memory-metadata">${essentialTags}</div>` : ''}
                </div>
            `;
        });
        
        html += `</div>`;
    }
    
    // Show ungrouped memories
    if (ungrouped.length > 0) {
        html += `<div class="memory-bucket">`;
        html += `<div class="memory-bucket-header">`;
        html += `<div class="memory-bucket-title">üì¶ Ungrouped</div>`;
        html += `<div class="memory-bucket-count">${ungrouped.length} memory${ungrouped.length > 1 ? 'ies' : ''}</div>`;
        html += `</div>`;
        
        ungrouped.forEach((memory, index) => {
            // Ensure memory has proper structure
            if (!memory || typeof memory !== 'object') {
                console.warn('[displayMemories] Skipping invalid ungrouped memory:', memory);
                return;
            }
            
            // Extract memory text - handle both string and object formats
            let memoryText = '';
            
            // First, try memory.memory if it's a string (most common case)
            if (typeof memory.memory === 'string' && memory.memory.trim().length > 0) {
                // Check if it's a stringified object (starts with { or [)
                const trimmed = memory.memory.trim();
                if (trimmed.startsWith('{') || trimmed.startsWith('[') || trimmed.startsWith("'{")) {
                    // Try to parse it as JSON and extract the actual memory text
                    try {
                        // Handle Python dict-style strings (single quotes) by converting to double quotes
                        let jsonString = memory.memory.trim();
                        if (jsonString.startsWith("'") || jsonString.startsWith('"')) {
                            // Try to fix Python dict format
                            jsonString = jsonString.replace(/'/g, '"');
                        }
                        const parsed = JSON.parse(jsonString);
                        if (typeof parsed === 'string') {
                            memoryText = parsed;
                        } else if (parsed && typeof parsed === 'object') {
                            memoryText = parsed.memory || parsed.text || parsed.content || '';
                        }
                    } catch (e) {
                        // Not valid JSON, might be Python dict string - try to extract memory field manually
                        // Look for pattern like 'memory': 'actual text here'
                        const memoryMatch = memory.memory.match(/'memory':\s*['"]([^'"]+)['"]/);
                        if (memoryMatch && memoryMatch[1]) {
                            memoryText = memoryMatch[1];
                        } else {
                            // Skip stringified objects entirely
                            console.warn('[displayMemories] memory.memory appears to be stringified object, skipping:', memory.memory.substring(0, 100));
                        }
                    }
                } else {
                    // It's a regular string, use it
                    memoryText = memory.memory;
                }
            }
            
            // If still empty, try memory.text
            if (!memoryText && memory.text && typeof memory.text === 'string' && memory.text.trim().length > 0) {
                memoryText = memory.text;
            }
            
            // If memory.memory is an object, extract text from it
            if (!memoryText && typeof memory.memory === 'object' && memory.memory !== null) {
                memoryText = memory.memory.memory || memory.memory.text || memory.memory.content || '';
            }
            
            // Fallback: try other common text fields
            if (!memoryText) {
                const textFields = ['content', 'message', 'fact', 'insight'];
                for (const field of textFields) {
                    if (memory[field] && typeof memory[field] === 'string' && memory[field].trim().length > 0) {
                        memoryText = memory[field];
                        break;
                    }
                }
            }
            
            // Last resort: find any string property that looks like content (not metadata)
            if (!memoryText && typeof memory === 'object') {
                const skipKeys = ['id', 'hash', 'created_at', 'updated_at', 'user_id', 'role', 'metadata', 'bucket_id', 'context_id'];
                for (const [key, value] of Object.entries(memory)) {
                    if (skipKeys.includes(key)) continue;
                    if (typeof value === 'string' && value.trim().length > 0) {
                        // Skip if it looks like a stringified object or JSON
                        const trimmed = value.trim();
                        if (!trimmed.startsWith('{') && !trimmed.startsWith('[') && trimmed.length < 500) {
                            memoryText = value;
                            break;
                        }
                    }
                }
            }
            
            // Final fallback
            if (!memoryText || memoryText.trim().length === 0) {
                memoryText = 'Memory content unavailable';
            }
            
            // Clean up the text - remove any remaining object-like patterns
            memoryText = memoryText.trim();
            
            memoryText = escapeHtml(memoryText);
            const memoryId = String(memory.id || `mem-${index}`);
            const metadata = (memory.metadata && typeof memory.metadata === 'object') ? memory.metadata : {};
            
            // Truncate long memory text for compact display
            const maxLength = 120;
            const displayText = memoryText.length > maxLength 
                ? memoryText.substring(0, maxLength) + '...' 
                : memoryText;
            
            // Only show essential metadata tags (category, source) - hide others
            const essentialTags = Object.entries(metadata)
                .filter(([k]) => ['category', 'source'].includes(k))
                .map(([k, v]) => {
                    const extraClass = k === 'category' ? 'category' : k === 'source' ? 'source' : '';
                    return `<span class="metadata-tag ${extraClass}">${escapeHtml(String(v))}</span>`;
                }).join('');
            
            html += `
                <div class="memory-item" onclick="showMemoryDetails('${memoryId}')" title="${escapeHtml(memoryText)}">
                    <div class="memory-item-header">
                        <span class="memory-icon">üí≠</span>
                        <div class="memory-text">${displayText}</div>
                    </div>
                    ${essentialTags ? `<div class="memory-metadata">${essentialTags}</div>` : ''}
                </div>
            `;
        });
        
        html += `</div>`;
    }
    
    container.innerHTML = html;
    
    // Return counts for display feedback
    return { 
        displayedCount: filteredMemories.length, 
        totalCount: totalCount,
        filteredCount: validMemories.length - filteredMemories.length
    };
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function escapeJsString(str) {
    if (!str) return '';
    return String(str)
        .replace(/\\/g, '\\\\')
        .replace(/'/g, "\\'")
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r');
}



async function viewRawContent(memoryId, filename) {
    event?.stopPropagation(); // Prevent event bubbling
    event?.preventDefault();
    
    const resultsContainer = document.getElementById('memory-navigator-results');
    const rawContentContainer = document.getElementById('memory-navigator-raw-content');
    const loadingEl = document.getElementById('nav-raw-content-loading');
    const errorEl = document.getElementById('nav-raw-content-error');
    const textEl = document.getElementById('nav-raw-content-text');
    const filenameEl = document.getElementById('nav-raw-content-filename');
    
    if (!rawContentContainer || !resultsContainer) {
        console.error('Raw content container not found');
        return;
    }
    
    // Hide results, show raw content view
    resultsContainer.style.display = 'none';
    rawContentContainer.style.display = 'flex';
    
    filenameEl.textContent = filename || 'Source Document';
    
    // Reset state
    loadingEl.style.display = 'flex';
    errorEl.style.display = 'none';
    textEl.style.display = 'none';
    
    try {
        // Fetch raw content
        const response = await fetch(`/api/memories/${memoryId}/raw`);
        const data = await response.json();
        
        if (data.success && data.raw_content) {
            // Show content
            textEl.textContent = data.raw_content;
            loadingEl.style.display = 'none';
            textEl.style.display = 'block';
            
            // Update filename if available
            if (data.filename) {
                filenameEl.textContent = data.filename;
            }
        } else {
            // Show error
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            errorEl.innerHTML = `<p>‚ùå ${data.error || 'Could not load source content'}</p>`;
        }
    } catch (error) {
        console.error('Error fetching raw content:', error);
        loadingEl.style.display = 'none';
        errorEl.style.display = 'block';
        errorEl.innerHTML = `<p>‚ùå Error loading content: ${error.message}</p>`;
    }
}

function showMemoryNavigatorResults() {
    const resultsContainer = document.getElementById('memory-navigator-results');
    const rawContentContainer = document.getElementById('memory-navigator-raw-content');
    
    if (resultsContainer && rawContentContainer) {
        rawContentContainer.style.display = 'none';
        resultsContainer.style.display = 'block';
    }
}

function closeRawContentModal() {
    // Legacy function - now handled by showMemoryNavigatorResults
    showMemoryNavigatorResults();
}

// Close raw content view on Escape key (when in Memory Navigator)
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        const rawContentContainer = document.getElementById('memory-navigator-raw-content');
        if (rawContentContainer && rawContentContainer.style.display !== 'none') {
            showMemoryNavigatorResults();
        }
    }
});

function toggleFilters() {
    const filters = document.getElementById('memory-filters');
    const toggle = document.getElementById('filters-toggle');
    if (filters && toggle) {
        filters.classList.toggle('expanded');
        toggle.classList.toggle('active');
    }
}

function updateActiveFilters() {
    // Simplified: No filters in right panel anymore - filters moved to Memory Navigator
    const container = document.getElementById('active-filters');
    if (container) {
        container.innerHTML = '';
    }
}

function showMemoryDetails(memoryId) {
    console.log('Memory details for:', memoryId);
}


function applyMetadataFilter() {
    // Auto-refresh active context memories in real-time
    refreshMemories(null, 'general', 0, false).catch(err => 
        console.error('Failed to refresh memories:', err)
    );
}

function showMemoryStorageIndicator() {
    const indicator = document.getElementById('memory-storage-indicator');
    indicator.classList.add('show');
    setTimeout(() => { indicator.classList.remove('show'); }, 3000);
}

// searchMemories function removed - search moved to Memory Navigator modal


// ------------------------------------------------------------------
// SEND MESSAGE LOGIC (UPDATED FOR SERVER-SIDE PARSING)
// ------------------------------------------------------------------
async function sendMessage(event) {
    event.preventDefault();
    
    // Critical: Check WebSocket connection before allowing message send
    if (!isWebSocketConnected && !isConnecting) {
        // Try to reconnect if not already connecting
        if (!isConnecting) {
            connectMemoryWebSocket();
        }
        alert('Please wait for the connection to be established before sending messages.');
        return;
    }
    
    if (isConnecting) {
        alert('Connection in progress. Please wait...');
        return;
    }
    
    const input = document.getElementById('message-input');
    let message = input.value.trim();
    
    // We do NOT read files as text on client anymore. 
    // We send them as multipart form data.
    
    if (!message && selectedFiles.length === 0) {
        alert('Please enter a message or select files to upload.');
        return;
    }

    // Get category from selector if available, otherwise default to 'general'
    const categorySelect = document.getElementById('category-select');
    const category = categorySelect ? categorySelect.value : 'general';

    // Store files before clearing
    const filesToSend = [...selectedFiles];
    
    // Clear input and disable controls
    input.value = '';
    input.disabled = true;
    const sendBtn = document.getElementById('send-btn');
    sendBtn.disabled = true;
    sendBtn.classList.remove('active');
    sendBtn.textContent = '‚è≥';

    // Show memory extraction modal immediately when files are uploaded
    if (filesToSend.length > 0) {
        // Show modal immediately to block UI and show progress
        showMemoryLoadingModal('Starting file upload and memory extraction...', 5, 'starting');
        memoryExtractionInProgress = true;
        
        const filePreviewContainer = document.getElementById('file-preview-container');
        if (filePreviewContainer) {
            filesToSend.forEach(file => {
                const filePreviews = filePreviewContainer.querySelectorAll('.file-preview');
                filePreviews.forEach(preview => {
                    const fileNameEl = preview.querySelector('.file-preview-name');
                    if (fileNameEl && fileNameEl.textContent === file.name) {
                        preview.classList.add('processing');
                        preview.classList.remove('completed');
                        
                        // Add status indicator
                        let statusEl = preview.querySelector('.file-preview-status');
                        if (!statusEl) {
                            statusEl = document.createElement('div');
                            statusEl.className = 'file-preview-status';
                            preview.querySelector('.file-preview-info')?.appendChild(statusEl);
                        }
                        statusEl.innerHTML = '<span>‚è≥</span> <span>Uploading...</span>';
                        
                        // Add progress bar
                        let progressEl = preview.querySelector('.file-preview-progress');
                        if (!progressEl) {
                            progressEl = document.createElement('div');
                            progressEl.className = 'file-preview-progress';
                            progressEl.innerHTML = '<div class="file-preview-progress-bar" style="width: 30%"></div>';
                            preview.appendChild(progressEl);
                        }
                        
                        // Animate progress
                        const progressBar = progressEl.querySelector('.file-preview-progress-bar');
                        if (progressBar) {
                            setTimeout(() => progressBar.style.width = '60%', 300);
                            setTimeout(() => progressBar.style.width = '90%', 600);
                        }
                    }
                });
            });
        }
    }
    
    // Create a visual message for the user immediately
    let displayMessage = message;
    let memoryExtractionId = null;
    if (filesToSend.length > 0) {
        const fileNames = filesToSend.map(f => f.name).join(', ');
        const fileTag = `üìé Uploading ${filesToSend.length} file(s): ${fileNames}`;
        displayMessage = fileTag + (message ? `\n\n${message}` : '');
    }
    
    addMessage('user', displayMessage);
    const loadingId = addMessage('assistant', '<div class="typing-indicator"><span></span><span></span><span></span></div>');
    
    // Show memory extraction indicator after a brief delay
    if (filesToSend.length > 0) {
        setTimeout(() => {
            memoryExtractionId = addMessage('assistant', `
                <div class="memory-extraction-indicator">
                    <div class="memory-extraction-spinner">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83" opacity="0.5"/>
                        </svg>
                    </div>
                    <div class="memory-extraction-text">
                        <div class="memory-extraction-title">üß† Extracting memories...</div>
                        <div class="memory-extraction-subtitle">Analyzing document content and extracting key facts</div>
                    </div>
                </div>
            `);
        }, 800);
    }

    try {
        const formData = new FormData();
        formData.append('message', message || "");
        formData.append('category', category);

        // Append actual File objects to FormData
        if (filesToSend.length > 0) {
            console.log(`üì§ Sending ${filesToSend.length} file(s) to server`);
            filesToSend.forEach((file, index) => {
                console.log(`   üìé File ${index + 1}: ${file.name} (${file.size} bytes, type: ${file.type || 'unknown'})`);
                // Append each file with the same field name "files" so backend can receive List[UploadFile]
                formData.append('files', file);
            });
            
            // Verify files were added (FormData.getAll() shows all values for a key)
            const fileEntries = formData.getAll('files');
            console.log(`‚úÖ FormData verification: ${fileEntries.length} file(s) in FormData`);
            if (fileEntries.length !== filesToSend.length) {
                console.warn(`‚ö†Ô∏è Mismatch: Expected ${filesToSend.length} files, but FormData has ${fileEntries.length}`);
            }
        } else {
            console.log('No files to send');
        }
        
        // Debug: Log FormData contents
        // console.log('FormData keys:', Array.from(formData.keys()));
        // console.log('FormData entries count:', Array.from(formData.keys()).length);

        // Clear files from preview after creating FormData
        selectedFiles = [];
        updateFilePreview();

        // Get CSRF token from cookie
        const csrfToken = getCookie('csrf_token');
        // Note: CSRF might not be strictly required if handled by session/cookie alone, but included for completeness
        const headers = {};
        if (csrfToken) {
            headers['X-CSRF-Token'] = csrfToken;
        }

        const response = await fetch(`/api/conversations/${conversationId}/messages`, {
            method: 'POST',
            headers: headers,
            body: formData
            // Don't set Content-Type header - browser will set it with boundary for multipart/form-data
        });

        if (!response.ok) {
            let errorMsg = `Failed to send message (${response.status})`;
            try {
                const errorData = await response.json();
                if (errorData.detail) errorMsg = errorData.detail;
            } catch (e) {
                // Ignore json parse error
            }
            
            // If files were sent but request failed, provide specific feedback
            if (filesToSend.length > 0) {
                console.error(`‚ùå File upload failed: ${errorMsg}`);
                console.error(`   Attempted to send ${filesToSend.length} file(s)`);
            }
            
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        removeMessage(loadingId);
        
        // Update file previews to show upload completion
        if (filesToSend.length > 0) {
            const filePreviewContainer = document.getElementById('file-preview-container');
            if (filePreviewContainer) {
                filesToSend.forEach(file => {
                    const filePreviews = filePreviewContainer.querySelectorAll('.file-preview');
                    filePreviews.forEach(preview => {
                        const fileNameEl = preview.querySelector('.file-preview-name');
                        if (fileNameEl && fileNameEl.textContent === file.name) {
                            preview.classList.remove('processing');
                            preview.classList.add('completed');
                            
                            // Update status
                            const statusEl = preview.querySelector('.file-preview-status');
                            if (statusEl) {
                                statusEl.innerHTML = '<span>‚úÖ</span> <span>Uploaded</span>';
                            }
                            
                            // Complete progress bar
                            const progressBar = preview.querySelector('.file-preview-progress-bar');
                            if (progressBar) {
                                progressBar.style.width = '100%';
                                progressBar.style.background = 'linear-gradient(90deg, rgba(16, 185, 129, 1), rgba(59, 130, 246, 1))';
                            }
                            
                            // Fade out after completion
                            setTimeout(() => {
                                preview.style.opacity = '0';
                                preview.style.transform = 'translateX(20px) scale(0.95)';
                                setTimeout(() => {
                                    preview.remove();
                                    // Remove from selectedFiles array
                                    const index = selectedFiles.findIndex(f => f.name === file.name);
                                    if (index > -1) {
                                        selectedFiles.splice(index, 1);
                                    }
                                    // Update preview if all files are done
                                    if (selectedFiles.length === 0) {
                                        updateFilePreview();
                                    }
                                }, 300);
                            }, 1500);
                        }
                    });
                });
            }
        }
        
        // Remove memory extraction indicator if it exists (will be replaced by modal)
        if (memoryExtractionId) {
            removeMessage(memoryExtractionId);
            memoryExtractionId = null;
        }

        if (!data.success) {
            const errorMsg = data.error || 'Server returned an error';
            // If files were sent, mention it in the error
            if (filesToSend.length > 0) {
                throw new Error(`${errorMsg} (${filesToSend.length} file(s) may not have been processed)`);
            }
            throw new Error(errorMsg);
        }
        
        // Success feedback for file uploads
        if (filesToSend.length > 0) {
            console.log(`‚úÖ Successfully sent ${filesToSend.length} file(s) to server`);
            const fileNames = filesToSend.map(f => f.name).join(', ');
            // Show a brief success indicator (optional - can be enhanced with a toast notification)
            console.log(`   Files processed: ${fileNames}`);
        }

        let responseContent = data.message?.content || 'No response received';
        
        if (data.mem0_operations) {
            responseContent += `<span class="mem0-ops-badge" title="Category: ${data.mem0_operations.category}">Mem0: ${data.mem0_operations.category}</span>`;
        }
        
        if (data.memory_context) {
            const usedCount = data.memory_context.used_memories || 0;
            responseContent += `<span class="memory-context-badge ${usedCount===0?'no-memories':''}">${usedCount} memories</span>`;
        }

        addMessage('assistant', responseContent);
        showMemoryStorageIndicator();

        // Update Active Context with retrieved memories from RAG search
        if (data.memory_context && data.memory_context.retrieved_memories) {
            const retrievedMemories = data.memory_context.retrieved_memories;
            console.log(`üîç Updating Active Context with ${retrievedMemories.length} retrieved memories`);
            updateActiveContext(retrievedMemories);
        } else {
            // No memories retrieved - clear Active Context
            console.log('üîç No memories retrieved for this query');
            updateActiveContext([]);
        }

        // Set flag to indicate we're waiting for new memories (enables retry logic)
        // This is for Memory Navigator, not Active Context
        isWaitingForNewMemories = true;
        memoryExtractionInProgress = true; // Mark extraction as starting
        memoryRefreshAborted = false; // Reset abort flag
        memoryRefreshRetryCount = 0;

        // Refresh Memory Navigator after a delay to allow async memory processing
        // This gives Mem0 time to process and store memories asynchronously
        // Note: Active Context is updated above with retrieved memories, not refreshed here
        setTimeout(async () => {
            console.log('[Memory Navigator] Delayed refresh after message send (2.5s delay)');
            await refreshFileContexts();
            // Don't refresh Active Context here - it's updated with retrieved memories above
        }, 2500); // 2.5 second delay to allow memory processing

        // Note: Memory storage events will also come via WebSocket and trigger refresh

    } catch (error) {
        console.error('Send message error:', error);
        removeMessage(loadingId);
        
        // Show user-friendly error message
        let errorMsg = error.message || 'Failed to send message. Please try again.';
        
        // Provide helpful error messages for common issues
        if (errorMsg.includes('CSRF')) {
            errorMsg = 'Security token expired. Please refresh the page and try again.';
        } else if (errorMsg.includes('401') || errorMsg.includes('Authentication')) {
            errorMsg = 'Your session has expired. Please refresh the page.';
        } else if (errorMsg.includes('413') || errorMsg.includes('too large')) {
            errorMsg = 'File(s) are too large. Maximum size is 50MB per file.';
        }
        
        addMessage('assistant', `<div style="color: #f85149; padding: 12px; background: rgba(248, 81, 73, 0.1); border-radius: 8px; border-left: 3px solid #f85149;"><strong>‚ùå Error:</strong> ${errorMsg}</div>`);
        
        // Restore files to preview if error occurs, so user can try again
        if (filesToSend.length > 0) {
            selectedFiles = filesToSend;
            updateFilePreview();
        }
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        sendBtn.textContent = '‚û§';
        sendBtn.classList.toggle('active', input.value.trim().length > 0 || selectedFiles.length > 0);
        input.focus();
    }
}

function addMessage(role, content) {
    const container = document.getElementById('messages-container');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;
    messageDiv.id = `msg-${Date.now()}-${Math.random()}`;
    
    const avatarHTML = role === 'user' 
        ? `<svg class="avatar" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M50,4A46,46,0,1,1,4,50,46,46,0,0,1,50,4m0-4a50,50,0,1,0,50,50A50,50,0,0,0,50,0Z"/><path d="M50,62.5a18.75,18.75,0,1,1,18.75-18.75A18.77,18.77,0,0,1,50,62.5Z"/></svg>`
        : `<svg class="avatar" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="45" stroke="currentColor" stroke-width="5" fill="none" opacity="0.5"/><circle cx="50" cy="50" r="30" fill="currentColor"/><circle cx="50" cy="50" r="15" fill="#1a1b2f"/></svg>`;
    
    const time = new Date().toLocaleTimeString();
    const contentHTML = role === 'assistant' && content.includes('typing-indicator')
        ? content
        : `<div class="text">${content}</div><div class="message-time">${time}</div>`;

    messageDiv.innerHTML = avatarHTML + `<div class="message-content">${contentHTML}</div>`;
    container.appendChild(messageDiv);
    scrollToBottom();
    return messageDiv.id;
}

function removeMessage(id) {
    const el = document.getElementById(id);
    if(el) el.remove();
}

async function deleteConversation() {
    if (confirm('Delete this conversation?')) {
        await fetch(`/api/conversations/${conversationId}`, { method: 'DELETE', headers: {'X-CSRF-Token': getCookie('csrf_token')} });
        window.location.href = '/conversations';
    }
}

// Memory Navigator Functions
let selectedNavigatorBucket = null;

function showMemoryNavigator() {
    const modal = document.getElementById('memory-navigator-modal');
    const resultsContainer = document.getElementById('memory-navigator-results');
    const rawContentContainer = document.getElementById('memory-navigator-raw-content');
    
    if (modal) {
        modal.classList.add('show');
        loadNavigatorData();
        // Prevent body scroll
        document.body.style.overflow = 'hidden';
        
        // Ensure results view is shown (not raw content view)
        if (resultsContainer) {
            resultsContainer.style.display = 'block';
        }
        if (rawContentContainer) {
            rawContentContainer.style.display = 'none';
        }
    }
}

function hideMemoryNavigator() {
    const modal = document.getElementById('memory-navigator-modal');
    if (modal) {
        modal.classList.remove('show');
        // Restore body scroll
        document.body.style.overflow = '';
    }
}

async function loadNavigatorData() {
    try {
        // Load stats
        const statsResponse = await fetch('/api/memories/stats');
        if (statsResponse.ok) {
            const statsData = await statsResponse.json();
            if (statsData.success && statsData.stats) {
                // Update statistics
                const fileContexts = statsData.stats.file_contexts || {};
                const generalBuckets = statsData.stats.general_buckets || {};
                
                let totalMemories = 0;
                let totalBuckets = 0;
                let fileBuckets = 0;
                let generalBucketsCount = 0;
                
                Object.values(fileContexts).forEach(ctx => {
                    totalMemories += ctx.count || 0;
                    fileBuckets++;
                });
                
                Object.values(generalBuckets).forEach(bucket => {
                    totalMemories += bucket.count || 0;
                    generalBucketsCount++;
                });
                
                totalBuckets = fileBuckets + generalBucketsCount;
                
                document.getElementById('nav-total-memories').textContent = totalMemories;
                document.getElementById('nav-total-buckets').textContent = totalBuckets;
                document.getElementById('nav-file-buckets').textContent = fileBuckets;
                document.getElementById('nav-general-buckets').textContent = generalBucketsCount;
                
                // Load buckets list
                const bucketsList = document.getElementById('memory-navigator-buckets-list');
                if (bucketsList) {
                    let bucketsHtml = '';
                    
                    // Add general buckets
                    for (const [bucketId, info] of Object.entries(generalBuckets)) {
                        bucketsHtml += `
                            <div class="memory-navigator-bucket-item" onclick="selectNavigatorBucket('${bucketId}', 'general', '${escapeHtml(info.name)}')">
                                <div>
                                    <div style="font-weight: 600; color: #93c5fd; margin-bottom: 4px;">üìÅ ${escapeHtml(info.name)}</div>
                                    <div style="font-size: 11px; color: rgba(255,255,255,0.5);">General Bucket</div>
                                </div>
                                <div style="font-weight: 700; color: #93c5fd;">${info.count}</div>
                            </div>
                        `;
                    }
                    
                    // Add file buckets
                    for (const [filename, info] of Object.entries(fileContexts)) {
                        bucketsHtml += `
                            <div class="memory-navigator-bucket-item" onclick="selectNavigatorBucket('${info.context_id}', 'file', '${escapeHtml(filename)}')">
                                <div>
                                    <div style="font-weight: 600; color: #6ee7b7; margin-bottom: 4px;">üìÑ ${escapeHtml(filename)}</div>
                                    <div style="font-size: 11px; color: rgba(255,255,255,0.5);">File Bucket</div>
                                </div>
                                <div style="font-weight: 700; color: #6ee7b7;">${info.count}</div>
                            </div>
                        `;
                    }
                    
                    if (bucketsHtml === '') {
                        bucketsHtml = '<div style="padding: 20px; text-align: center; color: rgba(255,255,255,0.5);">No buckets yet. Start chatting or upload files!</div>';
                    }
                    
                    bucketsList.innerHTML = bucketsHtml;
                }
            }
        }
    } catch (error) {
        console.error('Failed to load navigator data:', error);
    }
}

async function selectNavigatorBucket(bucketId, bucketType, bucketName) {
    selectedNavigatorBucket = { bucketId, bucketType, bucketName };
    
    // Update active state
    const items = document.querySelectorAll('.memory-navigator-bucket-item');
    items.forEach(item => item.classList.remove('active'));
    if (event && event.currentTarget) {
        event.currentTarget.classList.add('active');
    }
    
    // Update search info
    const searchInfo = document.getElementById('nav-search-mode');
    if (searchInfo) {
        searchInfo.textContent = `Viewing: ${bucketName}`;
    }
    
    // Clear search input
    const searchInput = document.getElementById('nav-search-input');
    if (searchInput) {
        searchInput.value = '';
    }
    
    // Load memories for this bucket
    await loadNavigatorBucketMemories(bucketId);
}

async function loadNavigatorBucketMemories(bucketId) {
    const resultsContainer = document.getElementById('memory-navigator-results');
    if (!resultsContainer) return;
    
    resultsContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);"><div style="font-size: 24px; margin-bottom: 12px;">‚è≥</div><div>Loading memories...</div></div>';
    
    console.log(`üîç Loading memories for bucket_id: ${bucketId}`);
    
    try {
        const response = await fetch(`/api/memories/by-context?bucket_id=${encodeURIComponent(bucketId)}&limit=100`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log(`üì¶ API response for bucket_id=${bucketId}:`, {
            success: data.success,
            memoryCount: data.memories?.length || 0,
            firstMemory: data.memories?.[0] || null
        });
        
        if (data.success && data.memories) {
            // Filter out raw_content memories - show only fact extractions/insights
            const memories = data.memories.filter(m => {
                const memType = m.metadata?.memory_type;
                return memType !== 'raw_content';
            });
            
            console.log(`‚úÖ Filtered to ${memories.length} memories (from ${data.memories.length} total)`);
            
            if (memories.length === 0) {
                resultsContainer.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);">
                        <div style="font-size: 48px; margin-bottom: 16px;">üí≠</div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No memories found</div>
                        <div style="font-size: 13px;">This bucket doesn't have any memories yet</div>
                        <div style="font-size: 11px; margin-top: 12px; color: rgba(255,255,255,0.4);">Bucket ID: ${escapeHtml(bucketId)}</div>
                    </div>
                `;
                return;
            }
            
            let html = `<div style="margin-bottom: 16px; font-size: 14px; color: rgba(255,255,255,0.7);">Found ${memories.length} memory${memories.length !== 1 ? 'ies' : ''}</div>`;
            
            memories.forEach((memory, index) => {
                const memoryText = escapeHtml(memory.memory || memory.text || '');
                const metadata = memory.metadata || {};
                
                // Debug log first memory
                if (index === 0) {
                    console.log('   First memory sample:', {
                        id: memory.id,
                        memory: memoryText.substring(0, 50) + '...',
                        metadata: metadata,
                        bucket_id: memory.bucket_id || metadata.bucket_id || metadata.context_id
                    });
                }
                
                const metadataTags = Object.entries(metadata)
                    .filter(([k]) => !['context_id', 'context_type', 'filename', 'bucket_id', 'bucket_type', 'memory_type', 'associated_bucket_id'].includes(k))
                    .map(([k, v]) => {
                        const extraClass = k === 'category' ? 'category' : k === 'source' ? 'source' : '';
                        return `<span class="metadata-tag ${extraClass}">${escapeHtml(String(v))}</span>`;
                    }).join('');
                
                    // Add View Source button for file memories
                    const hasRawContent = metadata.filename || metadata.raw_content_id || metadata.source === 'file_upload';
                    const safeFilename = escapeJsString(metadata.filename || 'Document');
                    const safeMemoryId = escapeJsString(String(memory.id || `mem-${index}`));
                    const viewSourceBtn = hasRawContent && metadata.bucket_type === 'file'
                        ? `<button class="view-source-btn" onclick="event.stopPropagation(); event.preventDefault(); viewRawContent('${safeMemoryId}', '${safeFilename}'); return false;" title="View source document" style="margin-top: 8px;">
                            <span>üìÑ</span> View Source Document
                           </button>`
                        : '';
                
                html += `
                    <div class="memory-item" style="margin-bottom: 12px;">
                        <div class="memory-item-header">
                            <span class="memory-icon">${metadata.bucket_type === 'file' ? 'üìÑ' : 'üí≠'}</span>
                            <div class="memory-text">${memoryText}</div>
                        </div>
                        ${metadataTags ? `<div class="memory-metadata">${metadataTags}</div>` : ''}
                        ${viewSourceBtn}
                    </div>
                `;
            });
            
            resultsContainer.innerHTML = html;
        } else {
            console.warn('‚ö†Ô∏è API returned success=false or no memories array:', data);
            resultsContainer.innerHTML = `
                <div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);">
                    <div style="font-size: 48px; margin-bottom: 16px;">üí≠</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No memories found</div>
                    <div style="font-size: 13px;">API response: ${escapeHtml(JSON.stringify(data))}</div>
                </div>
            `;
        }
    } catch (error) {
        console.error('‚ùå Failed to load bucket memories:', error);
        resultsContainer.innerHTML = `
            <div style="padding: 40px; text-align: center; color: rgba(248, 81, 73, 0.8);">
                <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error loading memories</div>
                <div style="font-size: 13px;">${escapeHtml(error.message || 'Unknown error')}</div>
                <div style="font-size: 11px; margin-top: 12px; color: rgba(248, 81, 73, 0.6);">Bucket ID: ${escapeHtml(bucketId)}</div>
            </div>
        `;
    }
}

function navigatorSearch(event) {
    const query = event.target.value.trim();
    const resultsContainer = document.getElementById('memory-navigator-results');
    const searchInfo = document.getElementById('nav-search-mode');
    
    if (!query) {
        // If no query and bucket selected, reload bucket memories
        if (selectedNavigatorBucket) {
            if (searchInfo) searchInfo.textContent = `Viewing: ${selectedNavigatorBucket.bucketName}`;
            loadNavigatorBucketMemories(selectedNavigatorBucket.bucketId);
        } else {
            if (searchInfo) searchInfo.textContent = 'Select a bucket or search all memories';
            resultsContainer.innerHTML = `
                <div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);">
                    <div style="font-size: 48px; margin-bottom: 16px;">üß≠</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Select a bucket to explore</div>
                    <div style="font-size: 13px;">Choose a bucket from the sidebar or search all memories</div>
                </div>
            `;
        }
        return;
    }
    
    // Search: if bucket selected, search within bucket; otherwise search all
    if (selectedNavigatorBucket) {
        if (searchInfo) searchInfo.textContent = `Searching in: ${selectedNavigatorBucket.bucketName}`;
        searchNavigatorMemories(query, selectedNavigatorBucket.bucketId);
    } else {
        if (searchInfo) searchInfo.textContent = 'Searching all memories...';
        searchNavigatorMemories(query, null);
    }
}

async function searchNavigatorMemories(query, bucketId) {
    const resultsContainer = document.getElementById('memory-navigator-results');
    if (!resultsContainer) return;
    
    resultsContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);"><div style="font-size: 24px; margin-bottom: 12px;">‚è≥</div><div>Searching...</div></div>';
    
    try {
        // Build search URL - search all if bucketId is null
        let url = `/api/memories/search?query=${encodeURIComponent(query)}&limit=50`;
        if (bucketId) {
            url += `&context_id=${encodeURIComponent(bucketId)}`;
        }
        
        const response = await fetch(url);
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.results) {
                // Filter out raw_content memories - show only fact extractions/insights
                const memories = data.results.filter(m => {
                    const memType = m.metadata?.memory_type;
                    return memType !== 'raw_content';
                });
                
                if (memories.length === 0) {
                    resultsContainer.innerHTML = `
                        <div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);">
                            <div style="font-size: 48px; margin-bottom: 16px;">üîç</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No results found</div>
                            <div style="font-size: 13px;">Try different search terms</div>
                        </div>
                    `;
                    return;
                }
                
                const scopeText = bucketId ? `in selected bucket` : `across all memories`;
                let html = `<div style="margin-bottom: 16px; font-size: 14px; color: rgba(255,255,255,0.7);">Found ${memories.length} result${memories.length !== 1 ? 's' : ''} ${scopeText} for "${escapeHtml(query)}"</div>`;
                
                memories.forEach((memory) => {
                    const memoryText = escapeHtml(memory.memory || '');
                    const metadata = memory.metadata || {};
                    const bucketName = metadata.bucket_id ? (metadata.category || metadata.filename || 'Unknown bucket') : '';
                    const metadataTags = Object.entries(metadata)
                        .filter(([k]) => !['context_id', 'context_type', 'filename', 'bucket_id', 'bucket_type', 'memory_type'].includes(k))
                        .map(([k, v]) => {
                            const extraClass = k === 'category' ? 'category' : k === 'source' ? 'source' : '';
                            return `<span class="metadata-tag ${extraClass}">${escapeHtml(String(v))}</span>`;
                        }).join('');
                    
                    const bucketBadge = bucketName ? `<span class="metadata-tag" style="background: rgba(138, 43, 226, 0.2); color: #c084fc;">üìÅ ${escapeHtml(bucketName)}</span>` : '';
                    
                    // Add View Source button for file memories
                    const hasRawContent = metadata.filename || metadata.raw_content_id || metadata.source === 'file_upload';
                    const safeFilename = escapeJsString(metadata.filename || 'Document');
                    const safeMemoryId = escapeJsString(String(memory.id || 'unknown'));
                    const viewSourceBtn = hasRawContent && metadata.bucket_type === 'file'
                        ? `<button class="view-source-btn" onclick="event.stopPropagation(); event.preventDefault(); viewRawContent('${safeMemoryId}', '${safeFilename}'); return false;" title="View source document" style="margin-top: 8px;">
                            <span>üìÑ</span> View Source Document
                           </button>`
                        : '';
                    
                    html += `
                        <div class="memory-item" style="margin-bottom: 12px;">
                            <div class="memory-item-header">
                                <span class="memory-icon">${metadata.bucket_type === 'file' ? 'üìÑ' : 'üí≠'}</span>
                                <div class="memory-text">${memoryText}</div>
                            </div>
                            ${bucketBadge ? `<div class="memory-metadata" style="margin-top: 8px;">${bucketBadge}</div>` : ''}
                            ${metadataTags ? `<div class="memory-metadata">${metadataTags}</div>` : ''}
                            ${viewSourceBtn}
                        </div>
                    `;
                });
                
                resultsContainer.innerHTML = html;
            }
        }
    } catch (error) {
        console.error('Failed to search navigator memories:', error);
        resultsContainer.innerHTML = `
            <div style="padding: 40px; text-align: center; color: #f85149;">
                <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                <div style="font-size: 16px; font-weight: 600;">Search failed</div>
                <div style="font-size: 13px;">${escapeHtml(error.message || 'Unknown error')}</div>
            </div>
        `;
    }
}

// Close modal on escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        hideMemoryNavigator();
        hideAddCategoryModal();
        hideFileExplorer();
    }
});

// Close modal when clicking outside
document.getElementById('memory-navigator-modal')?.addEventListener('click', (e) => {
    if (e.target.id === 'memory-navigator-modal') {
        hideMemoryNavigator();
    }
});

document.getElementById('file-explorer-modal')?.addEventListener('click', (e) => {
    if (e.target.id === 'file-explorer-modal') {
        hideFileExplorer();
    }
});

// File Explorer Functions
let currentFileExplorerBucketId = null;
let currentFileExplorerBucketName = null;
let bucketFilesCache = {};

function showFileExplorer(bucketId, bucketName) {
    currentFileExplorerBucketId = bucketId;
    currentFileExplorerBucketName = bucketName;
    
    const modal = document.getElementById('file-explorer-modal');
    const titleElement = document.getElementById('file-explorer-bucket-name');
    
    if (modal && titleElement) {
        titleElement.textContent = `File Explorer - ${bucketName}`;
        modal.classList.add('show');
        document.body.style.overflow = 'hidden';
        loadBucketFiles(bucketId);
    }
}

function hideFileExplorer() {
    const modal = document.getElementById('file-explorer-modal');
    if (modal) {
        modal.classList.remove('show');
        document.body.style.overflow = '';
        currentFileExplorerBucketId = null;
        currentFileExplorerBucketName = null;
    }
}

async function loadBucketFiles(bucketId) {
    const listContainer = document.getElementById('file-explorer-list');
    if (!listContainer) return;
    
    listContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);"><div style="font-size: 24px; margin-bottom: 12px;">‚è≥</div><div>Loading files...</div></div>';
    
    try {
        const response = await fetch(`/api/buckets/${encodeURIComponent(bucketId)}/files`);
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.files) {
                bucketFilesCache[bucketId] = data.files;
                displayBucketFiles(data.files);
            } else {
                listContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);"><div style="font-size: 48px; margin-bottom: 16px;">üìÅ</div><div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No files yet</div><div style="font-size: 13px;">Upload files to add them to this bucket</div></div>';
            }
        } else {
            throw new Error('Failed to load files');
        }
    } catch (error) {
        console.error('Failed to load bucket files:', error);
        listContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: #f85149;"><div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div><div style="font-size: 16px; font-weight: 600;">Error loading files</div></div>';
    }
}

function displayBucketFiles(files) {
    const listContainer = document.getElementById('file-explorer-list');
    if (!listContainer) return;
    
    if (files.length === 0) {
        listContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: rgba(255,255,255,0.5);"><div style="font-size: 48px; margin-bottom: 16px;">üìÅ</div><div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No files yet</div><div style="font-size: 13px;">Upload files to add them to this bucket</div></div>';
        return;
    }
    
    let html = '';
    files.forEach(file => {
        const fileIcon = getFileIcon(file.filename);
        const safeFilename = escapeHtml(file.filename);
        // bucket_id IS the file identifier - use it consistently
        const fileBucketId = file.bucket_id || file.file_context_id; // Support both for backward compatibility
        const safeBucketId = escapeJsString(fileBucketId);
        const uploadDate = file.upload_date ? new Date(file.upload_date).toLocaleDateString() : 'Unknown';
        
        html += `
            <div class="file-explorer-item">
                <div class="file-explorer-item-info">
                    <div class="file-explorer-item-icon">${fileIcon}</div>
                    <div class="file-explorer-item-details">
                        <div class="file-explorer-item-name">${safeFilename}</div>
                        <div class="file-explorer-item-meta">${file.memory_count || 0} memories ‚Ä¢ Uploaded ${uploadDate}</div>
                    </div>
                </div>
                <div class="file-explorer-item-actions">
                    <button class="file-explorer-action-btn" onclick="viewFileMemories('${safeBucketId}', '${safeFilename}')" title="View memories">
                        View
                    </button>
                    <button class="file-explorer-action-btn remove" onclick="removeFileFromBucket('${safeBucketId}', '${safeFilename}')" title="Remove from bucket">
                        Remove
                    </button>
                </div>
            </div>
        `;
    });
    
    listContainer.innerHTML = html;
}

function filterBucketFiles(event) {
    const searchTerm = event.target.value.toLowerCase();
    const bucketId = currentFileExplorerBucketId;
    
    if (!bucketId || !bucketFilesCache[bucketId]) return;
    
    const filteredFiles = bucketFilesCache[bucketId].filter(file => 
        file.filename.toLowerCase().includes(searchTerm)
    );
    
    displayBucketFiles(filteredFiles);
}

async function handleFileExplorerFileSelect(event) {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;
    
    await addFileToBucket(currentFileExplorerBucketId, files);
    event.target.value = ''; // Reset input
}

async function handleFileExplorerDrop(event) {
    event.preventDefault();
    const files = Array.from(event.dataTransfer.files);
    if (files.length === 0) return;
    
    await addFileToBucket(currentFileExplorerBucketId, files);
}

async function addFileToBucket(bucketId, files) {
    if (!bucketId || !files || files.length === 0) return;
    
    const formData = new FormData();
    files.forEach(file => {
        formData.append('files', file);
    });
    
    try {
        const response = await fetch(`/api/buckets/${encodeURIComponent(bucketId)}/files`, {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            const data = await response.json();
            if (data.success) {
                // Reload files
                await loadBucketFiles(bucketId);
                // Refresh file contexts globally
                await refreshFileContexts();
                // Refresh memories to update bucket headers
                await refreshMemories(null, 'general');
                
                // Show success notification
            } else {
                throw new Error(data.error || 'Failed to add files');
            }
        } else {
            throw new Error('Server error');
        }
    } catch (error) {
        console.error('Failed to add files to bucket:', error);
    }
}

async function removeFileFromBucket(bucketId, filename) {
    // bucket_id IS the file identifier
    if (!confirm(`Remove "${filename}" from this bucket? This will not delete the file memories, only the association.`)) {
        return;
    }
    
    // Note: This is a placeholder - actual implementation would require a DELETE endpoint
    // For now, we'll just show a message
    console.log('Remove file from bucket:', bucketId, filename);
}

function viewFileMemories(bucketId, filename) {
    // bucket_id IS the file identifier - use it to view memories
    // Open Memory Navigator and select this file bucket
    showMemoryNavigator();
    
    // Select the file bucket in the navigator
    setTimeout(() => {
        selectNavigatorBucket(bucketId, 'file', filename);
    }, 100);
    
    hideFileExplorer();
}
</script>
{% endblock %}